'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Stream = require('stream');
var http = require('http');
var Url = require('url');
var https = require('https');
var zlib = require('zlib');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Stream__default = /*#__PURE__*/_interopDefaultLegacy(Stream);
var http__default = /*#__PURE__*/_interopDefaultLegacy(http);
var Url__default = /*#__PURE__*/_interopDefaultLegacy(Url);
var https__default = /*#__PURE__*/_interopDefaultLegacy(https);
var zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var nodePonyfill = {exports: {}};

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = Stream__default['default'].Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = require('encoding').convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = Stream__default['default'].PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof Stream__default['default']) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof Stream__default['default']) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof Stream__default['default'])) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof Stream__default['default'] && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof Stream__default['default']) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find$1(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find$1(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find$1(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find$1(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find$1(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find$1(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find$1(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http__default['default'].STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = Url__default['default'].parse;
const format_url = Url__default['default'].format;

const streamDestructionSupported = 'destroy' in Stream__default['default'].Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parse_url(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parse_url(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parse_url(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof Stream__default['default'].Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = Stream__default['default'].PassThrough;
const resolve_url = Url__default['default'].resolve;

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch$1(url, opts) {

	// allow custom promise
	if (!fetch$1.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch$1.Promise;

	// wrap http.request into fetch
	return new fetch$1.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https__default['default'] : http__default['default']).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof Stream__default['default'].Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch$1.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				const locationURL = location === null ? null : resolve_url(request.url, location);

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch$1(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib__default['default'].Z_SYNC_FLUSH,
				finishFlush: zlib__default['default'].Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib__default['default'].createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib__default['default'].createInflate());
					} else {
						body = body.pipe(zlib__default['default'].createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib__default['default'].createBrotliDecompress === 'function') {
				body = body.pipe(zlib__default['default'].createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch$1.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch$1.Promise = global.Promise;

var lib = /*#__PURE__*/Object.freeze({
	__proto__: null,
	'default': fetch$1,
	Headers: Headers,
	Request: Request,
	Response: Response,
	FetchError: FetchError
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(lib);

(function (module, exports) {
const nodeFetch = require$$0;
const realFetch = nodeFetch.default || nodeFetch;

const fetch = function (url, options) {
  // Support schemaless URIs on the server for parity with the browser.
  // Ex: //github.com/ -> https://github.com/
  if (/^\/\//.test(url)) {
    url = 'https:' + url;
  }
  return realFetch.call(this, url, options)
};

fetch.ponyfill = true;

module.exports = exports = fetch;
exports.fetch = fetch;
exports.Headers = nodeFetch.Headers;
exports.Request = nodeFetch.Request;
exports.Response = nodeFetch.Response;

// Needed for TypeScript consumers without esModuleInterop.
exports.default = fetch;
}(nodePonyfill, nodePonyfill.exports));

var fetch = nodePonyfill.exports;

var queryString = {};

var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

var decodeUriComponent = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};

var splitOnFirst = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};

var filterObj = function (obj, predicate) {
	var ret = {};
	var keys = Object.keys(obj);
	var isArr = Array.isArray(predicate);

	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var val = obj[key];

		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
			ret[key] = val;
		}
	}

	return ret;
};

(function (exports) {
const strictUriEncode$1 = strictUriEncode;
const decodeComponent = decodeUriComponent;
const splitOnFirst$1 = splitOnFirst;
const filterObject = filterObj;

const isNullOrUndefined = value => value === null || value === undefined;

const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[', index, ']'].join('')];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
				];
			};

		case 'bracket':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[]'].join('')];
				}

				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
			};

		case 'comma':
		case 'separator':
		case 'bracket-separator': {
			const keyValueSep = options.arrayFormat === 'bracket-separator' ?
				'[]=' :
				'=';

			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				// Translate null to an empty string so that it doesn't serialize as 'null'
				value = value === null ? '' : value;

				if (result.length === 0) {
					return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};
		}

		default:
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, encode(key, options)];
				}

				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
				const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
				value = isEncodedArray ? decode(value, options) : value;
				const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		case 'bracket-separator':
			return (key, value, accumulator) => {
				const isArray = /(\[\])$/.test(key);
				key = key.replace(/\[\]$/, '');

				if (!isArray) {
					accumulator[key] = value ? decode(value, options) : value;
					return;
				}

				const arrayValue = value === null ?
					[] :
					value.split(options.arrayFormatSeparator).map(item => decode(item, options));

				if (accumulator[key] === undefined) {
					accumulator[key] = arrayValue;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], arrayValue);
			};

		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(query, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof query !== 'string') {
		return ret;
	}

	query = query.trim().replace(/^[?#&]/, '');

	if (!query) {
		return ret;
	}

	for (const param of query.split('&')) {
		if (param === '') {
			continue;
		}

		let [key, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, ' ') : param, '=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (const key of Object.keys(ret)) {
		const value = ret[key];
		if (typeof value === 'object' && value !== null) {
			for (const k of Object.keys(value)) {
				value[k] = parseValue(value[k], options);
			}
		} else {
			ret[key] = parseValue(value, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
				return encode(key, options) + '[]';
			}

			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (url, options) => {
	options = Object.assign({
		decode: true
	}, options);

	const [url_, hash] = splitOnFirst$1(url, '#');

	return Object.assign(
		{
			url: url_.split('?')[0] || '',
			query: parse(extract(url), options)
		},
		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
	);
};

exports.stringifyUrl = (object, options) => {
	options = Object.assign({
		encode: true,
		strict: true,
		[encodeFragmentIdentifier]: true
	}, options);

	const url = removeHash(object.url).split('?')[0] || '';
	const queryFromUrl = exports.extract(object.url);
	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

	const query = Object.assign(parsedQueryFromUrl, object.query);
	let queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = `?${queryString}`;
	}

	let hash = getHash(object.url);
	if (object.fragmentIdentifier) {
		hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
	}

	return `${url}${queryString}${hash}`;
};

exports.pick = (input, filter, options) => {
	options = Object.assign({
		parseFragmentIdentifier: true,
		[encodeFragmentIdentifier]: false
	}, options);

	const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
	return exports.stringifyUrl({
		url,
		query: filterObject(query, filter),
		fragmentIdentifier
	}, options);
};

exports.exclude = (input, filter, options) => {
	const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

	return exports.pick(input, exclusionFilter, options);
};
}(queryString));

const HOST = 'https://api.themoviedb.org/';
let v3Key;
let v4Key;

const removeUndefinedValues = (paramsObject) => {
  const finalParams = {};

  Object.keys(paramsObject).forEach((paramKey) => {
    if (typeof paramsObject[paramKey] !== 'undefined') {
      finalParams[paramKey] = paramsObject[paramKey];
    }
  });

  return finalParams;
};

const prepareData = (data) => JSON.stringify(removeUndefinedValues(data));

const setV3Key = (key) => {
  v3Key = key;
};

const setV4Key = (key) => {
  v4Key = key;
};

const makeHttpRequest = async (
  url,
  data = {},
  httpMethod = 'get',
  v4Options = {}
) => {
  try {
    // NOTE: Some v4 methods depend on an user access token as an apiV4Key
    const { usev4, userAccessToken } = v4Options;
    const finalVersion = usev4 ? 4 : 3;
    const originalUrl = `${HOST}${finalVersion}${url}?`;
    const originalHeaders = {
      'content-type': 'application/json;charset=utf-8',
    };
    let finalUrl = usev4 ? originalUrl : `${originalUrl}api_key=${v3Key}&`;
    const method = httpMethod.toLowerCase();
    const v4Token = userAccessToken ? userAccessToken : v4Key;
    const headers = usev4
      ? { ...originalHeaders, authorization: `Bearer ${v4Token}` }
      : originalHeaders;

    const fetchOptions = {
      method,
      headers,
    };

    if (['get', 'delete'].includes(method)) {
      finalUrl = finalUrl.concat(queryString.stringify(data));
    } else {
      fetchOptions.body = prepareData(data);
    }

    const response = await fetch(finalUrl, fetchOptions);

    if (response.ok) {
      return await response.json();
    }

    return Promise.reject(response.statusText);
  } catch (error) {
    return Promise.reject(error);
  }
};

const ACCOUNT_ADD_TO_WATCHLIST = '/account/:id/watchlist';
const ACCOUNT_DETAILS = '/account';
const ACCOUNT_FAVORITE_MOVIES$1 = '/account/:id/favorite/movies';
const ACCOUNT_FAVORITE_TV_SHOWS$1 = '/account/:id/favorite/tv';
const ACCOUNT_LISTS$1 = '/account/:id/lists';
const ACCOUNT_MARK_AS_FAVORITE = '/account/:id/favorite';
const ACCOUNT_MOVIE_WATCHLIST$1 = '/account/:id/watchlist/movies';
const ACCOUNT_RATED_MOVIES$1 = '/account/:id/rated/movies';
const ACCOUNT_RATED_TV_SHOWS$1 = '/account/:id/rated/tv';
const ACCOUNT_RATED_TV_SHOWS_EPISODES = '/account/:id/rated/tv/episodes';
const ACCOUNT_TV_SHOW_WATCHLIST$1 = '/account/:id/watchlist/tv';
const AUTHENTICATION_LOGOUT = '/authentication/session';
const AUTHENTICATION_NEW_GUEST_SESSION =
  '/authentication/guest_session/new';
const AUTHENTICATION_NEW_SESSION = '/authentication/session/new';
const AUTHENTICATION_NEW_TOKEN = '/authentication/token/new';
const AUTHENTICATION_SESSION_CONVERT =
  '/authentication/session/convert/4';
const AUTHENTICATION_TOKEN_VALIDATE_LOGIN =
  '/authentication/token/validate_with_login';
const CERTIFICATION_MOVIES = '/certification/movie/list';
const CERTIFICATION_TV_SHOWS = '/certification/tv/list';
const CHANGE_MOVIES = '/movie/changes';
const CHANGE_PERSON = '/person/changes';
const CHANGE_TV_SHOWS = '/tv/changes';
const COLLECTION_DETAILS = '/collection/:id';
const COLLECTION_IMAGES = '/collection/:id/images';
const COLLECTION_TRANSLATIONS = '/collection/:id/translations';
const COMPANY_ALTERNATIVE_NAMES = '/company/:id/alternative_names';
const COMPANY_DETAILS = '/company/:id';
const COMPANY_IMAGES = '/company/:id/images';
const CONFIGURATION_API = '/configuration';
const CONFIGURATION_COUNTRIES = '/configuration/countries';
const CONFIGURATION_JOBS = '/configuration/jobs';
const CONFIGURATION_LANGUAGES = '/configuration/languages';
const CONFIGURATION_PRIMARY_TRANSLATIONS =
  '/configuration/primary_translations';
const CONFIGURATION_TIMEZONES = '/configuration/timezones';
const CREDIT_DETAILS = '/credit/:id';
const DISCOVER_MOVIE = '/discover/movie';
const DISCOVER_TV_SHOW = '/discover/tv';
const FIND_EXTERNAL_ID = '/find/:externalId';
const GENRE_MOVIE_LIST = '/genre/movie/list';
const GENRE_TV_LIST = '/genre/tv/list';
const GUEST_SESSION_RATED_MOVIES = '/guest_session/:id/rated/movies';
const GUEST_SESSION_RATED_TV_EPISODES =
  '/guest_session/:id/rated/tv/episodes';
const GUEST_SESSION_RATED_TV_SHOWS = '/guest_session/:id/rated/tv';
const KEYWORD_DETAILS = '/keyword/:id';
const KEYWORD_MOVIES = '/keyword/:id/movies';
const LIST_ADD_MOVIE = '/list/:id/add_item';
const LIST_CLEAR = '/list/:id/clear';
const LIST_CREATE = '/list';
const LIST_DELETE = '/list/:id';
const LIST_DETAILS = '/list/:id';
const LIST_ITEM_STATUS = '/list/:id/item_status';
const LIST_REMOVE_MOVIE = '/list/:id/remove_item';
const MOVIE_ACCOUNT_STATES = '/movie/:id/account_states';
const MOVIE_ALTERNATIVE_TITLES = '/movie/:id/alternative_titles';
const MOVIE_CHANGES = '/movie/:id/changes';
const MOVIE_CREDITS = '/movie/:id/credits';
const MOVIE_DELETE_RATING = '/movie/:id/rating';
const MOVIE_DETAILS = '/movie/:id';
const MOVIE_EXTERNAL_IDS = '/movie/:id/external_ids';
const MOVIE_IMAGES = '/movie/:id/images';
const MOVIE_KEYWORDS = '/movie/:id/keywords';
const MOVIE_LATEST = '/movie/latest';
const MOVIE_LISTS = '/movie/:id/lists';
const MOVIE_NOW_PLAYING = '/movie/now_playing';
const MOVIE_POPULAR = '/movie/popular';
const MOVIE_RATING = '/movie/:id/rating';
const MOVIE_RECOMMENDATIONS = '/movie/:id/recommendations';
const MOVIE_RELEASE_DATES = '/movie/:id/release_dates';
const MOVIE_REVIEWS = '/movie/:id/reviews';
const MOVIE_SIMILAR = '/movie/:id/similar';
const MOVIE_TOP_RATED = '/movie/top_rated';
const MOVIE_TRANSLATIONS = '/movie/:id/translations';
const MOVIE_UPCOMING = '/movie/upcoming';
const MOVIE_WATCH_PROVIDERS = '/movie/:id/watch/providers';
const MOVIE_VIDEOS = '/movie/:id/videos';
const NETWORK_DETAILS = '/network/:id';
const NETWORK_ALTERNATIVE_NAMES = '/network/:id/alternative_names';
const NETWORK_IMAGES = '/network/:id/images';
const PEOPLE_CHANGES = '/person/:id/changes';
const PEOPLE_COMBINED_CREDITS = '/person/:id/combined_credits';
const PEOPLE_DETAILS = '/person/:id';
const PEOPLE_EXTERNAL_IDS = '/person/:id/external_ids';
const PEOPLE_LATEST = '/person/latest';
const PEOPLE_IMAGES = '/person/:id/images';
const PEOPLE_MOVIE_CREDITS = '/person/:id/movie_credits';
const PEOPLE_POPULAR = '/person/popular';
const PEOPLE_TAGGED_IMAGES = '/person/:id/tagged_images';
const PEOPLE_TRANSLATIONS = '/person/:id/translations';
const PEOPLE_TV_CREDITS = '/person/:id/tv_credits';
const REVIEW_DETAILS = '/review/:id';
const SEARCH_COLLECTION = '/search/collection';
const SEARCH_COMPANY = '/search/company';
const SEARCH_KEYWORD = '/search/keyword';
const SEARCH_MOVIE = '/search/movie';
const SEARCH_MULTI = '/search/multi';
const SEARCH_PEOPLE = '/search/person';
const SEARCH_TV = '/search/tv';
const TRENDING_ITEMS = '/trending/:mediaType/:timeWindow';
const TV_ACCOUNT_STATES = '/tv/:id/account_states';
const TV_AGGREGATE_CREDITS = '/tv/:id/aggregate_credits';
const TV_AIRING_TODAY = '/tv/airing_today';
const TV_ALTERNATIVE_TITLES = '/tv/:id/alternative_titles';
const TV_CHANGES = '/tv/:id/changes';
const TV_CONTENT_RATINGS = '/tv/:id/content_ratings';
const TV_CREDITS = '/tv/:id/credits';
const TV_DETAILS = '/tv/:id';
const TV_EPISODE_GROUPS = '/tv/:id/episode_groups';
const TV_EXTERNAL_IDS = '/tv/:id/external_ids';
const TV_IMAGES = '/tv/:id/images';
const TV_KEYWORDS = '/tv/:id/keywords';
const TV_LATEST = '/tv/latest';
const TV_ON_THE_AIR = '/tv/on_the_air';
const TV_POPULAR = '/tv/popular';
const TV_RATING = '/tv/:id/rating';
const TV_RECOMMENDATIONS = '/tv/:id/recommendations';
const TV_REVIEWS = '/tv/:id/reviews';
const TV_SCREENED_THEATRICALLY = '/tv/:id/screened_theatrically';
const TV_SIMILAR = '/tv/:id/similar';
const TV_TOP_RATED = '/tv/top_rated';
const TV_TRANSLATIONS = '/tv/:id/translations';
const TV_VIDEOS = '/tv/:id/videos';
const TV_WATCH_PROVIDERS = '/tv/:id/watch/providers';
const TV_EPISODE_ACCOUNT_STATES =
  '/tv/:tvId/season/:seasonNumber/episode/:episodeNumber/account_states';
const TV_EPISODE_CHANGES = '/tv/episode/:episodeId/changes';
const TV_EPISODE_CREDITS =
  '/tv/:tvId/season/:seasonNumber/episode/:episodeNumber/credits';
const TV_EPISODE_DETAILS =
  '/tv/:tvId/season/:seasonNumber/episode/:episodeNumber';
const TV_EPISODE_EXTERNAL_IDS =
  '/tv/:tvId/season/:seasonNumber/episode/:episodeNumber/external_ids';
const TV_EPISODE_IMAGES =
  '/tv/:tvId/season/:seasonNumber/episode/:episodeNumber/images';
const TV_EPISODE_RATING =
  '/tv/:tvId/season/:seasonNumber/episode/:episodeNumber/rating';
const TV_EPISODE_TRANSLATIONS =
  '/tv/:tvId/season/:seasonNumber/episode/:episodeNumber/translations';
const TV_EPISODE_VIDEOS =
  '/tv/:tvId/season/:seasonNumber/episode/:episodeNumber/videos';
const TV_EPISODE_GROUP_DETAILS = '/tv/episode_group/:id';
const TV_SEASON_ACCOUNT_STATES =
  '/tv/:tvId/season/:seasonNumber/account_states';
const TV_SEASON_AGGREGATE_CREDITS =
  '/tv/:id/season/:seasonNumber/aggregate_credits';
const TV_SEASON_CHANGES = '/tv/season/:seasonId/changes';
const TV_SEASON_CREDITS = '/tv/:tvId/season/:seasonNumber/credits';
const TV_SEASON_DETAILS = '/tv/:tvId/season/:seasonNumber';
const TV_SEASON_EXTERNAL_IDS =
  '/tv/:tvId/season/:seasonNumber/external_ids';
const TV_SEASON_IMAGES = '/tv/:tvId/season/:seasonNumber/images';
const TV_SEASON_TRANSLATIONS =
  '/tv/:tvId/season/:seasonNumber/translations';
const TV_SEASON_VIDEOS = '/tv/:tvId/season/:seasonNumber/videos';
const WATCH_PROVIDERS_AVAILABLE_REGIONS = '/watch/providers/regions';
const WATCH_PROVIDERS_MOVIE = '/watch/providers/movie';
const WATCH_PROVIDERS_TV = '/watch/providers/tv';

var v3$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ACCOUNT_ADD_TO_WATCHLIST: ACCOUNT_ADD_TO_WATCHLIST,
	ACCOUNT_DETAILS: ACCOUNT_DETAILS,
	ACCOUNT_FAVORITE_MOVIES: ACCOUNT_FAVORITE_MOVIES$1,
	ACCOUNT_FAVORITE_TV_SHOWS: ACCOUNT_FAVORITE_TV_SHOWS$1,
	ACCOUNT_LISTS: ACCOUNT_LISTS$1,
	ACCOUNT_MARK_AS_FAVORITE: ACCOUNT_MARK_AS_FAVORITE,
	ACCOUNT_MOVIE_WATCHLIST: ACCOUNT_MOVIE_WATCHLIST$1,
	ACCOUNT_RATED_MOVIES: ACCOUNT_RATED_MOVIES$1,
	ACCOUNT_RATED_TV_SHOWS: ACCOUNT_RATED_TV_SHOWS$1,
	ACCOUNT_RATED_TV_SHOWS_EPISODES: ACCOUNT_RATED_TV_SHOWS_EPISODES,
	ACCOUNT_TV_SHOW_WATCHLIST: ACCOUNT_TV_SHOW_WATCHLIST$1,
	AUTHENTICATION_LOGOUT: AUTHENTICATION_LOGOUT,
	AUTHENTICATION_NEW_GUEST_SESSION: AUTHENTICATION_NEW_GUEST_SESSION,
	AUTHENTICATION_NEW_SESSION: AUTHENTICATION_NEW_SESSION,
	AUTHENTICATION_NEW_TOKEN: AUTHENTICATION_NEW_TOKEN,
	AUTHENTICATION_SESSION_CONVERT: AUTHENTICATION_SESSION_CONVERT,
	AUTHENTICATION_TOKEN_VALIDATE_LOGIN: AUTHENTICATION_TOKEN_VALIDATE_LOGIN,
	CERTIFICATION_MOVIES: CERTIFICATION_MOVIES,
	CERTIFICATION_TV_SHOWS: CERTIFICATION_TV_SHOWS,
	CHANGE_MOVIES: CHANGE_MOVIES,
	CHANGE_PERSON: CHANGE_PERSON,
	CHANGE_TV_SHOWS: CHANGE_TV_SHOWS,
	COLLECTION_DETAILS: COLLECTION_DETAILS,
	COLLECTION_IMAGES: COLLECTION_IMAGES,
	COLLECTION_TRANSLATIONS: COLLECTION_TRANSLATIONS,
	COMPANY_ALTERNATIVE_NAMES: COMPANY_ALTERNATIVE_NAMES,
	COMPANY_DETAILS: COMPANY_DETAILS,
	COMPANY_IMAGES: COMPANY_IMAGES,
	CONFIGURATION_API: CONFIGURATION_API,
	CONFIGURATION_COUNTRIES: CONFIGURATION_COUNTRIES,
	CONFIGURATION_JOBS: CONFIGURATION_JOBS,
	CONFIGURATION_LANGUAGES: CONFIGURATION_LANGUAGES,
	CONFIGURATION_PRIMARY_TRANSLATIONS: CONFIGURATION_PRIMARY_TRANSLATIONS,
	CONFIGURATION_TIMEZONES: CONFIGURATION_TIMEZONES,
	CREDIT_DETAILS: CREDIT_DETAILS,
	DISCOVER_MOVIE: DISCOVER_MOVIE,
	DISCOVER_TV_SHOW: DISCOVER_TV_SHOW,
	FIND_EXTERNAL_ID: FIND_EXTERNAL_ID,
	GENRE_MOVIE_LIST: GENRE_MOVIE_LIST,
	GENRE_TV_LIST: GENRE_TV_LIST,
	GUEST_SESSION_RATED_MOVIES: GUEST_SESSION_RATED_MOVIES,
	GUEST_SESSION_RATED_TV_EPISODES: GUEST_SESSION_RATED_TV_EPISODES,
	GUEST_SESSION_RATED_TV_SHOWS: GUEST_SESSION_RATED_TV_SHOWS,
	KEYWORD_DETAILS: KEYWORD_DETAILS,
	KEYWORD_MOVIES: KEYWORD_MOVIES,
	LIST_ADD_MOVIE: LIST_ADD_MOVIE,
	LIST_CLEAR: LIST_CLEAR,
	LIST_CREATE: LIST_CREATE,
	LIST_DELETE: LIST_DELETE,
	LIST_DETAILS: LIST_DETAILS,
	LIST_ITEM_STATUS: LIST_ITEM_STATUS,
	LIST_REMOVE_MOVIE: LIST_REMOVE_MOVIE,
	MOVIE_ACCOUNT_STATES: MOVIE_ACCOUNT_STATES,
	MOVIE_ALTERNATIVE_TITLES: MOVIE_ALTERNATIVE_TITLES,
	MOVIE_CHANGES: MOVIE_CHANGES,
	MOVIE_CREDITS: MOVIE_CREDITS,
	MOVIE_DELETE_RATING: MOVIE_DELETE_RATING,
	MOVIE_DETAILS: MOVIE_DETAILS,
	MOVIE_EXTERNAL_IDS: MOVIE_EXTERNAL_IDS,
	MOVIE_IMAGES: MOVIE_IMAGES,
	MOVIE_KEYWORDS: MOVIE_KEYWORDS,
	MOVIE_LATEST: MOVIE_LATEST,
	MOVIE_LISTS: MOVIE_LISTS,
	MOVIE_NOW_PLAYING: MOVIE_NOW_PLAYING,
	MOVIE_POPULAR: MOVIE_POPULAR,
	MOVIE_RATING: MOVIE_RATING,
	MOVIE_RECOMMENDATIONS: MOVIE_RECOMMENDATIONS,
	MOVIE_RELEASE_DATES: MOVIE_RELEASE_DATES,
	MOVIE_REVIEWS: MOVIE_REVIEWS,
	MOVIE_SIMILAR: MOVIE_SIMILAR,
	MOVIE_TOP_RATED: MOVIE_TOP_RATED,
	MOVIE_TRANSLATIONS: MOVIE_TRANSLATIONS,
	MOVIE_UPCOMING: MOVIE_UPCOMING,
	MOVIE_WATCH_PROVIDERS: MOVIE_WATCH_PROVIDERS,
	MOVIE_VIDEOS: MOVIE_VIDEOS,
	NETWORK_DETAILS: NETWORK_DETAILS,
	NETWORK_ALTERNATIVE_NAMES: NETWORK_ALTERNATIVE_NAMES,
	NETWORK_IMAGES: NETWORK_IMAGES,
	PEOPLE_CHANGES: PEOPLE_CHANGES,
	PEOPLE_COMBINED_CREDITS: PEOPLE_COMBINED_CREDITS,
	PEOPLE_DETAILS: PEOPLE_DETAILS,
	PEOPLE_EXTERNAL_IDS: PEOPLE_EXTERNAL_IDS,
	PEOPLE_LATEST: PEOPLE_LATEST,
	PEOPLE_IMAGES: PEOPLE_IMAGES,
	PEOPLE_MOVIE_CREDITS: PEOPLE_MOVIE_CREDITS,
	PEOPLE_POPULAR: PEOPLE_POPULAR,
	PEOPLE_TAGGED_IMAGES: PEOPLE_TAGGED_IMAGES,
	PEOPLE_TRANSLATIONS: PEOPLE_TRANSLATIONS,
	PEOPLE_TV_CREDITS: PEOPLE_TV_CREDITS,
	REVIEW_DETAILS: REVIEW_DETAILS,
	SEARCH_COLLECTION: SEARCH_COLLECTION,
	SEARCH_COMPANY: SEARCH_COMPANY,
	SEARCH_KEYWORD: SEARCH_KEYWORD,
	SEARCH_MOVIE: SEARCH_MOVIE,
	SEARCH_MULTI: SEARCH_MULTI,
	SEARCH_PEOPLE: SEARCH_PEOPLE,
	SEARCH_TV: SEARCH_TV,
	TRENDING_ITEMS: TRENDING_ITEMS,
	TV_ACCOUNT_STATES: TV_ACCOUNT_STATES,
	TV_AGGREGATE_CREDITS: TV_AGGREGATE_CREDITS,
	TV_AIRING_TODAY: TV_AIRING_TODAY,
	TV_ALTERNATIVE_TITLES: TV_ALTERNATIVE_TITLES,
	TV_CHANGES: TV_CHANGES,
	TV_CONTENT_RATINGS: TV_CONTENT_RATINGS,
	TV_CREDITS: TV_CREDITS,
	TV_DETAILS: TV_DETAILS,
	TV_EPISODE_GROUPS: TV_EPISODE_GROUPS,
	TV_EXTERNAL_IDS: TV_EXTERNAL_IDS,
	TV_IMAGES: TV_IMAGES,
	TV_KEYWORDS: TV_KEYWORDS,
	TV_LATEST: TV_LATEST,
	TV_ON_THE_AIR: TV_ON_THE_AIR,
	TV_POPULAR: TV_POPULAR,
	TV_RATING: TV_RATING,
	TV_RECOMMENDATIONS: TV_RECOMMENDATIONS,
	TV_REVIEWS: TV_REVIEWS,
	TV_SCREENED_THEATRICALLY: TV_SCREENED_THEATRICALLY,
	TV_SIMILAR: TV_SIMILAR,
	TV_TOP_RATED: TV_TOP_RATED,
	TV_TRANSLATIONS: TV_TRANSLATIONS,
	TV_VIDEOS: TV_VIDEOS,
	TV_WATCH_PROVIDERS: TV_WATCH_PROVIDERS,
	TV_EPISODE_ACCOUNT_STATES: TV_EPISODE_ACCOUNT_STATES,
	TV_EPISODE_CHANGES: TV_EPISODE_CHANGES,
	TV_EPISODE_CREDITS: TV_EPISODE_CREDITS,
	TV_EPISODE_DETAILS: TV_EPISODE_DETAILS,
	TV_EPISODE_EXTERNAL_IDS: TV_EPISODE_EXTERNAL_IDS,
	TV_EPISODE_IMAGES: TV_EPISODE_IMAGES,
	TV_EPISODE_RATING: TV_EPISODE_RATING,
	TV_EPISODE_TRANSLATIONS: TV_EPISODE_TRANSLATIONS,
	TV_EPISODE_VIDEOS: TV_EPISODE_VIDEOS,
	TV_EPISODE_GROUP_DETAILS: TV_EPISODE_GROUP_DETAILS,
	TV_SEASON_ACCOUNT_STATES: TV_SEASON_ACCOUNT_STATES,
	TV_SEASON_AGGREGATE_CREDITS: TV_SEASON_AGGREGATE_CREDITS,
	TV_SEASON_CHANGES: TV_SEASON_CHANGES,
	TV_SEASON_CREDITS: TV_SEASON_CREDITS,
	TV_SEASON_DETAILS: TV_SEASON_DETAILS,
	TV_SEASON_EXTERNAL_IDS: TV_SEASON_EXTERNAL_IDS,
	TV_SEASON_IMAGES: TV_SEASON_IMAGES,
	TV_SEASON_TRANSLATIONS: TV_SEASON_TRANSLATIONS,
	TV_SEASON_VIDEOS: TV_SEASON_VIDEOS,
	WATCH_PROVIDERS_AVAILABLE_REGIONS: WATCH_PROVIDERS_AVAILABLE_REGIONS,
	WATCH_PROVIDERS_MOVIE: WATCH_PROVIDERS_MOVIE,
	WATCH_PROVIDERS_TV: WATCH_PROVIDERS_TV
});

const ACCOUNT_FAVORITE_MOVIES = '/account/:id/movie/favorites';
const ACCOUNT_FAVORITE_TV_SHOWS = '/account/:id/tv/favorites';
const ACCOUNT_LIST_CLEAR_ITEMS = '/list/:id/clear';
const ACCOUNT_LIST_ITEM_STATUS = '/list/:id/item_status';
const ACCOUNT_LIST_ITEMS = '/list/:id/items';
const ACCOUNT_LIST_DETAILS = '/list/:id';
const ACCOUNT_LIST_CREATE = '/list';
const ACCOUNT_LISTS = '/account/:id/lists';
const ACCOUNT_MOVIE_RECOMMENDATIONS =
  '/account/:id/movie/recommendations';
const ACCOUNT_MOVIE_WATCHLIST = '/account/:id/movie/watchlist';
const ACCOUNT_RATED_MOVIES = '/account/:id/movie/rated';
const ACCOUNT_RATED_TV_SHOWS = '/account/:id/tv/rated';
const ACCOUNT_TV_SHOW_RECOMMENDATIONS =
  '/account/:id/tv/recommendations';
const ACCOUNT_TV_SHOW_WATCHLIST = '/account/:id/tv/watchlist';
const AUTH_ACCESS_TOKEN = '/auth/access_token';
const AUTH_REQUEST_TOKEN = '/auth/request_token';

var v4$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ACCOUNT_FAVORITE_MOVIES: ACCOUNT_FAVORITE_MOVIES,
	ACCOUNT_FAVORITE_TV_SHOWS: ACCOUNT_FAVORITE_TV_SHOWS,
	ACCOUNT_LIST_CLEAR_ITEMS: ACCOUNT_LIST_CLEAR_ITEMS,
	ACCOUNT_LIST_ITEM_STATUS: ACCOUNT_LIST_ITEM_STATUS,
	ACCOUNT_LIST_ITEMS: ACCOUNT_LIST_ITEMS,
	ACCOUNT_LIST_DETAILS: ACCOUNT_LIST_DETAILS,
	ACCOUNT_LIST_CREATE: ACCOUNT_LIST_CREATE,
	ACCOUNT_LISTS: ACCOUNT_LISTS,
	ACCOUNT_MOVIE_RECOMMENDATIONS: ACCOUNT_MOVIE_RECOMMENDATIONS,
	ACCOUNT_MOVIE_WATCHLIST: ACCOUNT_MOVIE_WATCHLIST,
	ACCOUNT_RATED_MOVIES: ACCOUNT_RATED_MOVIES,
	ACCOUNT_RATED_TV_SHOWS: ACCOUNT_RATED_TV_SHOWS,
	ACCOUNT_TV_SHOW_RECOMMENDATIONS: ACCOUNT_TV_SHOW_RECOMMENDATIONS,
	ACCOUNT_TV_SHOW_WATCHLIST: ACCOUNT_TV_SHOW_WATCHLIST,
	AUTH_ACCESS_TOKEN: AUTH_ACCESS_TOKEN,
	AUTH_REQUEST_TOKEN: AUTH_REQUEST_TOKEN
});

var urls = {
  v3: v3$1,
  v4: v4$1,
};

/**
 * @module account
 */

/**
 * Add a movie or TV show to your watchlist.
 * @param {number}  accountId - Required
 * @param {string}  sessionId - Required
 * @param {Object}  body - Required
 * @param {('movie'|'tv')}  body.media_type - Required - Allowed values: movie, tv
 * @param {number}  body.media_id - Required
 * @param {boolean} body.watchlist - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/add-to-watchlist
 */
const addToWatchlist = async (accountId, sessionId, body = {}) => {
  const { media_type, media_id, watchlist } = body;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!sessionId) {
    return Promise.reject('A sessionId has to be provided');
  }

  if (!body || !Object.keys(body).length) {
    return Promise.reject(
      'A body must have a media_type, media_id and watchlist keys'
    );
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_ADD_TO_WATCHLIST.replace(':id', accountId).concat(
      `?session_id=${sessionId}`
    ),
    { media_type, media_id, watchlist },
    'post'
  );
};

/**
 * Get your account details.
 * @param {string} sessionId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/get-account-details
 */
const details$e = async sessionId => {
  if (!sessionId) {
    return Promise.reject('A sessionId has to be provided');
  }

  return await makeHttpRequest(urls.v3.ACCOUNT_DETAILS, {
    session_id: sessionId,
  });
};

/**
 * Get the list of your favorite movies.
 * @param {number} accountId - Required
 * @param {Object} options
 * @param {string} options.session_id - Required
 * @param {string} options.language
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/get-favorite-movies
 */
const favoriteMovies$1 = async (accountId, options = {}) => {
  const { session_id, language, page, sort_by } = options;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_FAVORITE_MOVIES.replace(':id', accountId),
    { session_id, language, page, sort_by }
  );
};

/**
 * Get the list of your favorite TV shows.
 * @param {number} accountId - Required
 * @param {Object} options
 * @param {string} options.session_id - Required
 * @param {string} options.language
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/get-favorite-tv-shows
 */
const favoriteTvShows$1 = async (accountId, options = {}) => {
  const { session_id, language, page, sort_by } = options;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_FAVORITE_TV_SHOWS.replace(':id', accountId),
    { session_id, language, page, sort_by }
  );
};

/**
 * Get all of the lists created by an account. Will invlude private lists if you are the owner.
 * @param {number} accountId - Required
 * @param {Object} options
 * @param {string} options.session_id - Required
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/get-created-lists
 */
const lists$2 = async (accountId, options = {}) => {
  const { session_id, language, page } = options;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_LISTS.replace(':id', accountId),
    { session_id, language, page }
  );
};

/**
 * This method allows you to mark a movie or TV show as a favorite item.
 * @param {number} accountId - Required
 * @param {string} sessionId - Required
 * @param {Object} body - Required
 * @param {('movie'|'tv')} body.media_type - Required
 * @param {number} body.media_id - Required
 * @param {boolean} body.favorite - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/mark-as-favorite
 */
const markAsFavorite = async (accountId, sessionId, body = {}) => {
  const { media_type, media_id, favorite } = body;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!sessionId) {
    return Promise.reject('A sessionId has to be provided');
  }

  if (!body || !Object.keys(body).length) {
    return Promise.reject(
      'A body must have a media_type, media_id and favorite keys'
    );
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_MARK_AS_FAVORITE.replace(':id', accountId).concat(
      `?session_id=${sessionId}`
    ),
    { media_type, media_id, favorite },
    'post'
  );
};

/**
 * Get a list of all the movies you have added to your watchlist.
 * @param {number} accountId - Required
 * @param {Object} options
 * @param {string} options.session_id - Required
 * @param {string} options.language
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/get-movie-watchlist
 */
const movieWatchlist$1 = async (accountId, options = {}) => {
  const { session_id, language, page, sort_by } = options;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_MOVIE_WATCHLIST.replace(':id', accountId),
    { session_id, language, page, sort_by }
  );
};

/**
 * Get a list of all the movies you have rated.
 * @param {number} accountId - Required
 * @param {Object} options
 * @param {string} options.session_id - Required
 * @param {string} options.language
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/get-rated-movies
 */
const ratedMovies$2 = async (accountId, options = {}) => {
  const { session_id, language, page, sort_by } = options;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_RATED_MOVIES.replace(':id', accountId),
    { session_id, language, page, sort_by }
  );
};

/**
 * Get a list of all the TV shows you have rated.
 * @param {number} accountId - Required
 * @param {Object} options
 * @param {string} options.session_id - Required
 * @param {string} options.language
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/get-rated-tv-shows
 */
const ratedTvShows$2 = async (accountId, options = {}) => {
  const { session_id, language, page, sort_by } = options;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_RATED_TV_SHOWS.replace(':id', accountId),
    { session_id, language, page, sort_by }
  );
};

/**
 * Get a list of all the TV episodes you have rated.
 * @param {number} accountId - Required
 * @param {Object}  options
 * @param {string}  options.session_id - Required
 * @param {string}  options.language
 * @param {number}  options.page
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/get-rated-tv-episodes
 */
const ratedTvEpisodes$1 = async (accountId, options = {}) => {
  const { session_id, language, page, sort_by } = options;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_RATED_TV_SHOWS_EPISODES.replace(':id', accountId),
    { session_id, language, page, sort_by }
  );
};

/**
 * Get a list of all the TV shows you have added to your watchlist.
 * @param {number} accountId - Required
 * @param {Object} options
 * @param {string} options.session_id - Required
 * @param {string} options.language
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/account/get-tv-show-watchlist
 */
const tvShowWatchlist$1 = async (accountId, options = {}) => {
  const { session_id, language, page, sort_by } = options;
  if (!accountId && accountId !== 0) {
    return Promise.reject('An accountId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.ACCOUNT_MOVIE_WATCHLIST.replace(':id', accountId),
    { session_id, language, page, sort_by }
  );
};

var account$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	addToWatchlist: addToWatchlist,
	details: details$e,
	favoriteMovies: favoriteMovies$1,
	favoriteTvShows: favoriteTvShows$1,
	lists: lists$2,
	markAsFavorite: markAsFavorite,
	movieWatchlist: movieWatchlist$1,
	ratedMovies: ratedMovies$2,
	ratedTvShows: ratedTvShows$2,
	ratedTvEpisodes: ratedTvEpisodes$1,
	tvShowWatchlist: tvShowWatchlist$1
});

/**
 * @module authentication
 */

/**
 * If you would like to delete (or "logout") from a session, call this method with a valid session ID.
 * @param {string} sessionId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/authentication/delete-session
 */
const logout = async sessionId => {
  if (!sessionId) {
    return Promise.reject('A session id has to be provided');
  }

  return makeHttpRequest(
    urls.v3.AUTHENTICATION_LOGOUT,
    { session_id: sessionId },
    'delete'
  );
};

/**
 * This method will let you create a new guest session. Guest sessions are a type of session that will let a user rate movies and TV shows but not require them to have a TMDb user account.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/authentication/create-guest-session
 */
const newGuestSession = async () =>
  await makeHttpRequest(urls.v3.AUTHENTICATION_NEW_GUEST_SESSION);

/**
 * You can use this method to create a fully valid session ID once a user has validated the request token.
 * @param {string} requestToken
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/authentication/create-session
 */
const newSession = async requestToken => {
  if (!requestToken) {
    return Promise.reject('A request token has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.AUTHENTICATION_NEW_SESSION,
    { request_token: requestToken },
    'post'
  );
};

/**
 * Create a temporary request token that can be used to validate a TMDb user login.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/authentication/create-request-token
 */
const newToken = async () =>
  await makeHttpRequest(urls.v3.AUTHENTICATION_NEW_TOKEN);

/**
 * Use this method to create a v3 session ID if you already have a valid v4 access token.
 * The v4 token needs to be authenticated by the user. Your standard "read token" will not validate to create a session ID.
 * @param {string} v4AccessToken
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/authentication/create-session-from-v4-access-token
 */
const sessionConvert = async v4AccessToken => {
  if (!v4AccessToken) {
    return Promise.reject('A v4 access token has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.AUTHENTICATION_SESSION_CONVERT,
    { access_token: v4AccessToken },
    'post'
  );
};

/**
 * This method allows an application to validate a request token by entering a username and password.
 * Not all applications have access to a web view so this can be used as a substitute.
 * If you decide to use this method please use HTTPS.
 * @param {Object} options
 * @param {string} options.username
 * @param {string} options.password
 * @param {string} options.request_token
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/authentication/validate-request-token
 */
const validateWithLogin = async (options = {}) => {
  const { username, password, request_token } = options;

  if (!username || !password || !request_token) {
    return Promise.reject(
      'An username, password and a request_token has to be provided'
    );
  }

  return await makeHttpRequest(
    urls.v3.AUTHENTICATION_TOKEN_VALIDATE_LOGIN,
    { username, password, request_token },
    'post'
  );
};

var authentication$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	logout: logout,
	newGuestSession: newGuestSession,
	newSession: newSession,
	newToken: newToken,
	sessionConvert: sessionConvert,
	validateWithLogin: validateWithLogin
});

/**
 * @module certification
 */

/**
 * Get an up to date list of the officially supported movie certifications on TMDb.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/certifications/get-movie-certifications
 */
const movies$3 = async () => {
  return await makeHttpRequest(urls.v3.CERTIFICATION_MOVIES);
};

/**
 * Get an up to date list of the officially supported TV show certifications on TMDb.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/certifications/get-tv-certifications
 */
const tvShows$2 = async () => {
  return await makeHttpRequest(urls.v3.CERTIFICATION_TV_SHOWS);
};

var certification = /*#__PURE__*/Object.freeze({
	__proto__: null,
	movies: movies$3,
	tvShows: tvShows$2
});

/**
 * @module changes
 */

/**
 * Get a list of all of the movie ids that have been changed in the past 24 hours.
 * You can query it for up to 14 days worth of changed IDs at a time with the start_date and end_date query parameters. 100 items are returned per page.
 * @param {Object} options
 * @param {string} options.start_date
 * @param {string} options.end_date
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/changes/get-movie-change-list
 */
const movies$2 = async (options = {}) => {
  const { start_date, end_date, page } = options;

  return await makeHttpRequest(urls.v3.CHANGE_MOVIES, {
    start_date,
    end_date,
    page,
  });
};

/**
 * Get a list of all of the person ids that have been changed in the past 24 hours.
 * You can query it for up to 14 days worth of changed IDs at a time with the start_date and end_date query parameters. 100 items are returned per page.
 * @param {Object} options
 * @param {string} options.start_date
 * @param {string} options.end_date
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/changes/get-person-change-list
 */
const people$2 = async (options = {}) => {
  const { start_date, end_date, page } = options;

  return await makeHttpRequest(urls.v3.CHANGE_PERSON, {
    start_date,
    end_date,
    page,
  });
};

/**
 * Get a list of all of the TV show ids that have been changed in the past 24 hours.
 * You can query it for up to 14 days worth of changed IDs at a time with the start_date and end_date query parameters. 100 items are returned per page.
 * @param {Object} options
 * @param {string} options.start_date
 * @param {string} options.end_date
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/changes/get-tv-change-list
 */
const tvShows$1 = async (options = {}) => {
  const { start_date, end_date, page } = options;

  return await makeHttpRequest(urls.v3.CHANGE_TV_SHOWS, {
    start_date,
    end_date,
    page,
  });
};

var change = /*#__PURE__*/Object.freeze({
	__proto__: null,
	movies: movies$2,
	people: people$2,
	tvShows: tvShows$1
});

/**
 * @module collection
 */

/**
 * Get collection details by id.
 * @param {number} collectionId
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/collections/get-collection-details
 */
const details$d = async (collectionId, options = {}) => {
  const { language } = options;
  if (!collectionId && collectionId !== 0) {
    return Promise.reject('A collectionId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.COLLECTION_DETAILS.replace(':id', collectionId),
    {
      language,
    }
  );
};

/**
 * Get the images for a collection by id.
 * @param {number} collectionId
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/collections/get-collection-images
 */
const images$7 = async (collectionId, options = {}) => {
  const { language } = options;
  if (!collectionId && collectionId !== 0) {
    return Promise.reject('A collectionId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.COLLECTION_IMAGES.replace(':id', collectionId),
    {
      language,
    }
  );
};

/**
 * Get the list translations for a collection by id.
 * @param {number} collectionId
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/collections/get-collection-translations
 */
const translations$5 = async (collectionId, options = {}) => {
  const { language } = options;
  if (!collectionId && collectionId !== 0) {
    return Promise.reject('A collectionId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.COLLECTION_TRANSLATIONS.replace(':id', collectionId),
    {
      language,
    }
  );
};

var collection = /*#__PURE__*/Object.freeze({
	__proto__: null,
	details: details$d,
	images: images$7,
	translations: translations$5
});

/**
 * @module company
 */

/**
 * Get the alternative names of a company.
 * @param {number} companyId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/companies/get-company-alternative-names
 */
const alternativeNames$1 = async companyId => {
  if (!companyId && companyId !== 0) {
    return Promise.reject('A companyId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.COMPANY_ALTERNATIVE_NAMES.replace(':id', companyId)
  );
};

/**
 * Get a companies details by id.
 * @param {number} companyId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/companies/get-company-details
 */
const details$c = async companyId => {
  if (!companyId && companyId !== 0) {
    return Promise.reject('A companyId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.COMPANY_DETAILS.replace(':id', companyId)
  );
};

/**
 * Get a companies logos by id.
 * There are two image formats that are supported for companies, PNG"s and SVG"s.
 * You can see which type the original file is by looking at the file_type field.
 * We prefer SVG"s as they are resolution independent and as such, the width and height are only
 * there to reflect the original asset that was uploaded.
 * An SVG can be scaled properly beyond those dimensions if you call them as a PNG.
 * @param {number} companyId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/companies/get-company-images
 */
const images$6 = async companyId => {
  if (!companyId && companyId !== 0) {
    return Promise.reject('A companyId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.COMPANY_IMAGES.replace(':id', companyId)
  );
};

var company = /*#__PURE__*/Object.freeze({
	__proto__: null,
	alternativeNames: alternativeNames$1,
	details: details$c,
	images: images$6
});

/**
 * @module configuration
 */

/**
 * Get the system wide configuration information.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/configuration/get-api-configuration
 */
const api = async () => await makeHttpRequest(urls.v3.CONFIGURATION_API);
/**
 * Get the list of countries (ISO 3166-1 tags) used throughout TMDb.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/configuration/get-countries
 */
const countries = async () =>
  await makeHttpRequest(urls.v3.CONFIGURATION_COUNTRIES);

/**
 * Get a list of the jobs and departments we use on TMDb.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/configuration/get-jobs
 */
const jobs = async () =>
  await makeHttpRequest(urls.v3.CONFIGURATION_JOBS);

/**
 * Get the list of languages (ISO 639-1 tags) used throughout TMDb.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/configuration/get-languages
 */
const languages = async () =>
  await makeHttpRequest(urls.v3.CONFIGURATION_LANGUAGES);

/**
 * Get a list of the officially supported translations on TMDb.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/configuration/get-primary-translations
 */
const primaryTranslations = async () =>
  await makeHttpRequest(urls.v3.CONFIGURATION_PRIMARY_TRANSLATIONS);

/**
 * Get the list of timezones used throughout TMDb.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/configuration/get-timezones
 */
const timezones = async () =>
  await makeHttpRequest(urls.v3.CONFIGURATION_TIMEZONES);

var configuration = /*#__PURE__*/Object.freeze({
	__proto__: null,
	api: api,
	countries: countries,
	jobs: jobs,
	languages: languages,
	primaryTranslations: primaryTranslations,
	timezones: timezones
});

/**
 * @module credit
 */

/**
 * Get a movie or TV credit details by id.
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/credits/get-credit-details
 */
const details$b = async creditId => {
  if (!creditId) {
    return Promise.reject('A creditId has to be provided');
  }

  return await makeHttpRequest(urls.v3.CREDIT_DETAILS.replace(':id', creditId));
};

var credit = /*#__PURE__*/Object.freeze({
	__proto__: null,
	details: details$b
});

/**
 * @module discover
 */

/**
 * Discover movies by different types of data like average rating,
 * number of votes, genres and certifications.
 * For a full list of options, see https://developers.themoviedb.org/3/discover/movie-discover
 * @param {Object}  options
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/discover/movie-discover
 */
const movie$2 = async (options = {}) => {
  return await makeHttpRequest(urls.v3.DISCOVER_MOVIE, options);
};

/**
 * Discover TV shows by different types of data like average rating, number of votes, genres, the network they aired on and air dates.
 * For a full list of options, see https://developers.themoviedb.org/3/discover/tv-discover
 * @param {Object}  options
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/discover/tv-discover
 */
const tvShows = async (options = {}) => {
  return await makeHttpRequest(urls.v3.DISCOVER_TV_SHOW, options);
};

var discover = /*#__PURE__*/Object.freeze({
	__proto__: null,
	movie: movie$2,
	tvShows: tvShows
});

/**
 * @module find
 */

/**
 * The find method makes it easy to search for objects in our database by an external id. For example, an IMDB ID.
 * This method will search all objects (movies, TV shows and people) and return the results in a single response.
 * @param {Object} options
 * @param {string} options.external_id
 * @param {string} options.external_source - Possible values: imdb_id, freebase_mid, freebase_id, tvdb_id, tvrage_id
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/find/find-by-id
 */
const byId = async (options = {}) => {
  const { external_id, external_source, language } = options;

  if (!external_id) {
    return Promise.reject('An external_id has to be provided');
  }

  if (!external_source) {
    return Promise.reject('An external_source has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.FIND_EXTERNAL_ID.replace(':externalId', external_id),
    { external_source, language }
  );
};

var find = /*#__PURE__*/Object.freeze({
	__proto__: null,
	byId: byId
});

/**
 * @module genre
 */

/**
 * Get the list of official genres for movies.
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/genres/get-movie-list
 */
const movieList = async (options = {}) => {
  const { language } = options;

  return await makeHttpRequest(urls.v3.GENRE_MOVIE_LIST, { language });
};

/**
 * Get the list of official genres for TV shows.
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/genres/get-tv-list
 */
const tvList = async (options = {}) => {
  const { language } = options;

  return await makeHttpRequest(urls.v3.GENRE_TV_LIST, { language });
};

var genre = /*#__PURE__*/Object.freeze({
	__proto__: null,
	movieList: movieList,
	tvList: tvList
});

/**
 * @module guestSession
 */

/**
 * Get the rated movies for a guest session.
 * @param {string} guestSessionId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/guest-sessions/get-guest-session-rated-movies
 */
const ratedMovies$1 = async (guestSessionId, options = {}) => {
  const { language, sort_by } = options;
  if (!guestSessionId) {
    return Promise.reject('A guestSessionId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.GUEST_SESSION_RATED_MOVIES.replace(':id', guestSessionId),
    { language, sort_by }
  );
};

/**
 * Get the rated TV episodes for a guest session.
 * @param {string} guestSessionId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/guest-sessions/get-gest-session-rated-tv-episodes
 */
const ratedTvEpisodes = async (guestSessionId, options = {}) => {
  const { language, sort_by } = options;
  if (!guestSessionId) {
    return Promise.reject('A guestSessionId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.GUEST_SESSION_RATED_TV_EPISODES.replace(':id', guestSessionId),
    { language, sort_by }
  );
};

/**
 * Get the rated TV shows for a guest session.
 * @param {string} guestSessionId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {('created_at.asc'|'created_at.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/guest-sessions/get-guest-session-rated-tv-shows
 */
const ratedTvShows$1 = async (guestSessionId, options = {}) => {
  const { language, sort_by } = options;
  if (!guestSessionId) {
    return Promise.reject('A guestSessionId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.GUEST_SESSION_RATED_TV_SHOWS.replace(':id', guestSessionId),
    { language, sort_by }
  );
};

var guestSession = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ratedMovies: ratedMovies$1,
	ratedTvEpisodes: ratedTvEpisodes,
	ratedTvShows: ratedTvShows$1
});

/**
 * @module keyword
 */

/**
 * Get details of keyword
 * @param {number} keywordId - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/keywords/get-keyword-details
 */
const details$a = async keywordId => {
  if (!keywordId && keywordId !== 0) {
    return Promise.reject('A keywordId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.KEYWORD_DETAILS.replace(':id', keywordId)
  );
};

/**
 * Get the movies that belong to a keyword.
 * @param {number}  keywordId - Required
 * @param {Object}  options
 * @param {string}  options.language
 * @param {boolean} options.include_adult
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/keywords/get-movies-by-keyword
 */
const movies$1 = async (keywordId, options = {}) => {
  const { language, include_adult } = options;
  if (!keywordId && keywordId !== 0) {
    return Promise.reject('A keywordId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.KEYWORD_MOVIES.replace(':id', keywordId),
    { language, include_adult }
  );
};

var keyword = /*#__PURE__*/Object.freeze({
	__proto__: null,
	details: details$a,
	movies: movies$1
});

/**
 * @module list
 */

/**
 * Add a movie to a list.
 * @param {(string|number)}  listId - Required
 * @param {string}  sessionId - Required
 * @param {Object}  body - Required
 * @param {number}  body.media_id - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/lists/add-movie
 */
const addMovie = async (listId, sessionId, body = {}) => {
  const { media_id } = body;
  if (!listId) {
    return Promise.reject('A listId has to be provided');
  }

  if (!sessionId) {
    return Promise.reject('A sessionId has to be provided');
  }

  if (!body || !Object.keys(body).length) {
    return Promise.reject('The body must have a media_id');
  }

  return await makeHttpRequest(
    urls.v3.LIST_ADD_MOVIE.replace(':id', listId).concat(
      `?session_id=${sessionId}`
    ),
    { media_id },
    'post'
  );
};

/**
 * Clear all of the items from a list.
 * @param {string}  listId - Required
 * @param {Object}  options - Required
 * @param {string}  options.session_id - Required
 * @param {boolean} options.confirm - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/lists/clear-list
 */
const clear = async (listId, options = {}) => {
  const { session_id, confirm } = options;
  if (!listId) {
    return Promise.reject('A listId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  if (confirm === undefined) {
    return Promise.reject('A confirm option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.LIST_CLEAR.replace(':id', listId).concat(
      `?session_id=${session_id}&confirm=${confirm}`
    ),
    {},
    'post'
  );
};

/**
 * Create a list.
 * @param {string}  sessionId - Required
 * @param {Object}  body
 * @param {string}  body.name
 * @param {string}  body.description
 * @param {string}  body.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/lists/create-list
 */
const create$1 = async (sessionId, body = {}) => {
  const { name, description, language } = body;
  if (!sessionId) {
    return Promise.reject('A sessionId has to be provided');
  }

  if (!body || !Object.keys(body).length) {
    return Promise.reject(
      'A body must have a name, description and language keys'
    );
  }

  return await makeHttpRequest(
    urls.v3.LIST_CREATE.concat(`?session_id=${sessionId}`),
    { name, description, language },
    'post'
  );
};

/**
 * Get the details of a list.
 * @param {(number|string)}  listId - Required
 * @param {Object}  options
 * @param {string}  options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/lists/get-list-details
 */
const details$9 = async (listId, options = {}) => {
  const { language } = options;
  if (!listId) {
    return Promise.reject('A listId has to be provided');
  }

  return await makeHttpRequest(urls.v3.LIST_DETAILS.replace(':id', listId), {
    language,
  });
};

/**
 * You can use this method to check if a movie has already been added to the list.
 * @param {(number|string)}  listId - Required
 * @param {Object}  options
 * @param {string}  options.movieId - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/lists/check-item-status
 */
const itemStatus$1 = async (listId, options = {}) => {
  const { movie_id } = options;
  if (!listId) {
    return Promise.reject('A listId has to be provided');
  }

  if (!movie_id) {
    return Promise.reject('A movie_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.LIST_ITEM_STATUS.replace(':id', listId),
    { movie_id }
  );
};

/**
 * Delete a list.
 * @param {string}  listId - Required
 * @param {Object}  options - Required
 * @param {string}  options.session_id - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/lists/delete-list
 */
const remove$1 = async (listId, options = {}) => {
  const { session_id } = options;
  if (!listId) {
    return Promise.reject('A listId has to be provided');
  }

  if (!session_id) {
    return Promise.reject('A session_id option has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.LIST_DELETE.replace(':id', listId).concat(
      `?session_id=${session_id}`
    ),
    {},
    'delete'
  );
};

/**
 * Remove a movie from a list.
 * @param {(string|number)}  listId - Required
 * @param {string}  sessionId - Required
 * @param {Object}  body - Required
 * @param {number}  body.media_id - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/lists/remove-movie
 */
const removeMovie = async (listId, sessionId, body = {}) => {
  const { media_id } = body;
  if (!listId) {
    return Promise.reject('A listId has to be provided');
  }

  if (!sessionId) {
    return Promise.reject('A sessionId has to be provided');
  }

  if (!body || !Object.keys(body).length) {
    return Promise.reject('The body must have a media_id');
  }

  return await makeHttpRequest(
    urls.v3.LIST_REMOVE_MOVIE.replace(':id', listId).concat(
      `?session_id=${sessionId}`
    ),
    { media_id },
    'post'
  );
};

var list$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	addMovie: addMovie,
	clear: clear,
	create: create$1,
	details: details$9,
	itemStatus: itemStatus$1,
	remove: remove$1,
	removeMovie: removeMovie
});

/**
 * @module movie
 */

/**
 * Grab the following account states for a session:
 * - Movie rating
 * - If it belongs to your watchlist
 * - If it belongs to your favourite list
 * @param {number} movieId - Required
 * @param {Object} options
 * @param {string} options.session_id
 * @param {string} options.guest_session_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-account-states
 */
const accountStates$3 = async (movieId, options = {}) => {
  const { session_id, guest_session_id } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  if (session_id || guest_session_id) {
    return await makeHttpRequest(
      urls.v3.MOVIE_ACCOUNT_STATES.replace(':id', movieId),
      { session_id, guest_session_id }
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get all of the alternative titles for a movie.
 * @param {number} movieId
 * @param {Object} options
 * @param {string} options.country
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-alternative-titles
 */
const alternativeTitles$1 = async (movieId, options = {}) => {
  const { country } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.MOVIE_ALTERNATIVE_TITLES.replace(':id', movieId),
    { country }
  );
};

/**
 * Get the changes for a movie. By default only the last 24 hours are returned.
 * You can query up to 14 days in a single query by using the start_date and end_date query parameters.
 * @param {number} movieId
 * @param {Object} options
 * @param {string} options.start_date
 * @param {string} options.end_date
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-changes
 */
const changes$4 = async (movieId, options = {}) => {
  const { start_date, end_date } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return await makeHttpRequest(urls.v3.MOVIE_CHANGES.replace(':id', movieId), {
    start_date,
    end_date,
  });
};

/**
 * Get the cast and crew for a movie.
 * @param {number} movieId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-credits
 */
const credits$3 = async (movieId) => {
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return await makeHttpRequest(urls.v3.MOVIE_CREDITS.replace(':id', movieId));
};

/**
 * Remove your rating for a movie.
 * @param {number} movieId
 * @param {Object} options
 * @param {string} options.session_id
 * @param {string} options.guest_session_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/delete-movie-rating
 */
const deleteRating$2 = async (movieId, options = {}) => {
  const { session_id, guest_session_id } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  if (session_id || guest_session_id) {
    return await makeHttpRequest(
      urls.v3.MOVIE_DELETE_RATING.replace(':id', movieId),
      { session_id, guest_session_id },
      'delete'
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get the primary information about a movie.
 * @param {number} movieId
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.append_to_response
 * @param {string} options.include_image_language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-details
 */
const details$8 = async (movieId, options = {}) => {
  const { language, append_to_response, include_image_language } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return await makeHttpRequest(urls.v3.MOVIE_DETAILS.replace(':id', movieId), {
    language,
    append_to_response,
    include_image_language,
  });
};

/**
 * Get the external ids for a movie.
 * We currently support the following external sources: IMDB ID, Facebook, Instagram, Twitter.
 * @param {number} movieId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-external-ids
 */
const externalIds$4 = async (movieId) => {
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_EXTERNAL_IDS.replace(':id', movieId));
};

/**
 * Get the images that belong to a movie.
 * Querying images with a language parameter will filter the results.
 * If you want to include a fallback language (especially useful for backdrops) you can use the include_image_language parameter.
 * This should be a comma separated value like so: { include_image_language: "en,null" }.
 * @param {number} movieId
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.include_image_language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-images
 */
const images$5 = async (movieId, options = {}) => {
  const { language, include_image_language } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_IMAGES.replace(':id', movieId), {
    language,
    include_image_language,
  });
};

/**
 * Get the keywords that have been added to a movie.
 * @param {number} movieId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-keywords
 */
const keywords$2 = async (movieId) => {
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_KEYWORDS.replace(':id', movieId));
};

/**
 * Get the most newly created movie. This is a live response and will continuously change.
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-latest-movie
 */
const latest$2 = async (options = {}) => {
  const { language } = options;

  return await makeHttpRequest(urls.v3.MOVIE_LATEST, { language });
};

/**
 * @param {number} movieId
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-lists
 */
const lists$1 = async (movieId, options = {}) => {
  const { language, page } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_LISTS.replace(':id', movieId), {
    language,
    page,
  });
};

/**
 * Get a list of movies in theatres.
 * This is a release type query that looks for all movies that have a release type
 * of 2 or 3 within the specified date range.
 * You can optionally specify a region prameter which will narrow the search
 * to only look for theatrical release dates within the specified country.
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @param {string} options.region
 * @see https://developers.themoviedb.org/3/movies/get-now-playing
 */
const nowPlaying = async (options = {}) => {
  const { language, page, region } = options;
  return await makeHttpRequest(urls.v3.MOVIE_NOW_PLAYING, {
    language,
    page,
    region,
  });
};

/**
 * Get a list of the current popular movies on TMDb.
 * This list updates daily.
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @param {string} options.region
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-popular-movies
 */
const popular$2 = async (options = {}) => {
  const { language, page, region } = options;

  return await makeHttpRequest(urls.v3.MOVIE_POPULAR, {
    language,
    page,
    region,
  });
};

/**
 * Rate a movie.
 * @param {number} movieId - Required
 * @param {rating} rating - between 0.5 and 10.0
 * @param {Object} options
 * @param {string} options.guestSessionId
 * @param {string} options.sessionId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/rate-movie
 */
const rate$2 = async (movieId, rating, options = {}) => {
  const { session_id, guest_session_id } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  if (!rating) {
    return Promise.reject('A rating has to be provided');
  }

  if (session_id || guest_session_id) {
    const queryParam = session_id
      ? `?session_id=${session_id}`
      : `?guest_session_id=${guest_session_id}`;
    return await makeHttpRequest(
      urls.v3.MOVIE_RATING.replace(':id', movieId).concat(queryParam),
      { value: rating },
      'post'
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get a list of recommended movies for a movie.
 * @param {number} movieId
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-recommendations
 */
const recommendations$1 = async (movieId, options = {}) => {
  const { language, page } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(
    urls.v3.MOVIE_RECOMMENDATIONS.replace(':id', movieId),
    {
      language,
      page,
    }
  );
};

/**
 * Get the release date along with the certification for a movie.
 * Release dates support different types:
 * - Premiere
 * - Theatrical (limited)
 * - Theatrical
 * - Digital
 * - Physical
 * - TV
 * @param {number} movieId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-release-dates
 */
const releaseDates = async (movieId) => {
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_RELEASE_DATES.replace(':id', movieId));
};

/**
 * Get the user reviews for a movie.
 * @param {number} movieId
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-reviews
 */
const reviews$1 = async (movieId, options = {}) => {
  const { language, page } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_REVIEWS.replace(':id', movieId), {
    language,
    page,
  });
};

/**
 * Get a list of similar movies. This is not the same as the "Recommendation" system you see on the website.
 * These items are assembled by looking at keywords and genres.
 * @param {number} movieId
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-similar-movies
 */
const similar$1 = async (movieId, options = {}) => {
  const { language, page } = options;
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_SIMILAR.replace(':id', movieId), {
    language,
    page,
  });
};

/**
 * Get the top rated movies on TMDb.
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @param {string} options.region
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-top-rated-movies
 */
const topRated$1 = async (options = {}) => {
  const { language, page, region } = options;

  return makeHttpRequest(urls.v3.MOVIE_TOP_RATED, { language, page, region });
};

/**
 * Get a list of translations that have been created for a movie.
 * @param {number} movieId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-translations
 */
const translations$4 = async (movieId) => {
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_TRANSLATIONS.replace(':id', movieId));
};

/**
 * Get a list of upcoming movies in theatres.
 * This is a release type query that looks for all movies that
 * have a release type of 2 or 3 within the specified date range.
 * You can optionally specify a region parameter which will narrow the search to only look
 * for theatrical release dates within the specified country.
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @param {string} options.region
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-upcoming
 */
const upcoming = async (options = {}) => {
  const { language, page, region } = options;

  return makeHttpRequest(urls.v3.MOVIE_UPCOMING, { language, page, region });
};

/**
 * Get the videos that have been added to a movie.
 * @param {number} movieId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/movies/get-movie-videos
 */
const videos$3 = async (movieId) => {
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_VIDEOS.replace(':id', movieId));
};

/**
 * Powered by our partnership with JustWatch, you can query this method to get a list of the availabilities per country by provider.
 * This is not going to return full deep links, but rather, it's just enough information to display what's available where.
 * You can link to the provided TMDB URL to help support TMDB and provide the actual deep links to the content.
 * Please note: In order to use this data you must attribute the source of the data as JustWatch. If we find any usage not complying with these terms we will revoke access to the API.
 * @param {number} movieId
 * @return {Promise} Promise
 * @see https://developers.themoviedb.org/3/movies/get-movie-watch-providers
 */
const watchProviders$1 = async (movieId) => {
  if (!movieId) {
    return Promise.reject('A movieId has to be provided');
  }

  return makeHttpRequest(urls.v3.MOVIE_WATCH_PROVIDERS.replace(':id', movieId));
};

var movie$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	accountStates: accountStates$3,
	alternativeTitles: alternativeTitles$1,
	changes: changes$4,
	credits: credits$3,
	deleteRating: deleteRating$2,
	details: details$8,
	externalIds: externalIds$4,
	images: images$5,
	keywords: keywords$2,
	latest: latest$2,
	lists: lists$1,
	nowPlaying: nowPlaying,
	popular: popular$2,
	rate: rate$2,
	recommendations: recommendations$1,
	releaseDates: releaseDates,
	reviews: reviews$1,
	similar: similar$1,
	topRated: topRated$1,
	translations: translations$4,
	upcoming: upcoming,
	videos: videos$3,
	watchProviders: watchProviders$1
});

/**
 * @module network
 */

/**
 * Get the details of a network.
 * @param {number} networkId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/networks/get-network-details
 */
const details$7 = async networkId => {
  if (!networkId && networkId !== 0) {
    return Promise.reject('A networkId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.NETWORK_DETAILS.replace(':id', networkId)
  );
};

/**
 * Get the alternative names of a network.
 * @param {number} networkId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/networks/get-network-alternative-names
 */
const alternativeNames = async networkId => {
  if (!networkId && networkId !== 0) {
    return Promise.reject('A networkId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.NETWORK_ALTERNATIVE_NAMES.replace(':id', networkId)
  );
};

/**
 * Get the TV network logos by id.
 * There are two image formats that are supported for networks, PNG"s and SVG"s.
 * You can see which type the original file is by looking at the fileType field.
 * We prefer SVG"s as they are resolution independent and as such, the width and height are only
 * there to reflect the original asset that was uploaded.
 * An SVG can be scaled properly beyond those dimensions if you call them as a PNG.
 * @param {number} networkId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/networks/get-network-images
 */
const images$4 = async networkId => {
  if (!networkId && networkId !== 0) {
    return Promise.reject('A networkId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.NETWORK_IMAGES.replace(':id', networkId)
  );
};

var network = /*#__PURE__*/Object.freeze({
	__proto__: null,
	details: details$7,
	alternativeNames: alternativeNames,
	images: images$4
});

/**
 * @module people
 */

/**
 * Get the changes for a person. By default only the last 24 hours are returned.
 * You can query up to 14 days in a single query by using the start_date and end_date options.
 * @param {number} personId - Required
 * @param {Object} options
 * @param {string} options.start_date
 * @param {string} options.end_date
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-person-changes
 */
const changes$3 = async (personId, options = {}) => {
  const { start_date, end_date, page } = options;

  if (!personId && personId !== 0) {
    return Promise.reject('A personId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.PEOPLE_CHANGES.replace(':id', personId),
    {
      start_date,
      end_date,
      page,
    }
  );
};

/**
 * Get the movie and TV credits together in a single response.
 * @param {number} personId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-person-combined-credits
 */
const combinedCredits = async (personId, options = {}) => {
  const { language } = options;

  if (!personId && personId !== 0) {
    return Promise.reject('A personId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.PEOPLE_COMBINED_CREDITS.replace(':id', personId),
    {
      language,
    }
  );
};

/**
 * Get the primary person details by id.
 * @param {number} personId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.append_to_response
 * @param {string} options.include_image_language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-person-details
 */
const details$6 = async (personId, options = {}) => {
  const { language, append_to_response, include_image_language } = options;

  if (!personId && personId !== 0) {
    return Promise.reject('A personId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.PEOPLE_DETAILS.replace(':id', personId),
    {
      language,
      append_to_response,
      include_image_language,
    }
  );
};

/**
 * Get the external ids for a person. We currently support the following external sources.
 * IMDB ID, TVDB ID, Freebase MID, Freebase ID, TVRage ID, Instagram, Facebook, Twitter
 * @param {number} personId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-person-external-ids
 */
const externalIds$3 = async (personId, options = {}) => {
  const { language } = options;

  if (!personId && personId !== 0) {
    return Promise.reject('A personId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.PEOPLE_EXTERNAL_IDS.replace(':id', personId),
    {
      language,
    }
  );
};

/**
 * Get the images for a person.
 * @param {number} personId - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-person-images
 */
const images$3 = async personId => {
  if (!personId && personId !== 0) {
    return Promise.reject('A personId has to be provided');
  }

  return await makeHttpRequest(urls.v3.PEOPLE_IMAGES.replace(':id', personId));
};

/**
 * Get the most newly created person. This is a live response and will continuously change.
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-latest-person
 */
const latest$1 = async (options = {}) => {
  const { language } = options;

  return await makeHttpRequest(urls.v3.PEOPLE_LATEST, { language });
};

/**
 * Get the movie credits for a person.
 * @param {number} personId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-person-movie-credits
 */
const movieCredits = async (personId, options = {}) => {
  const { language } = options;

  if (!personId && personId !== 0) {
    return Promise.reject('A personId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.PEOPLE_MOVIE_CREDITS.replace(':id', personId),
    {
      language,
    }
  );
};

/**
 * Get the list of popular people on TMDb.
 * This list updates daily.
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-popular-people
 */
const popular$1 = async (options = {}) => {
  const { language, page } = options;

  return await makeHttpRequest(urls.v3.PEOPLE_POPULAR, {
    language,
    page,
  });
};

/**
 * Get the images that this person has been tagged in.
 * @param {number} personId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-tagged-images
 */
const taggedImages = async (personId, options = {}) => {
  const { language, page } = options;
  if (!personId && personId !== 0) {
    return Promise.reject('A personId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.PEOPLE_TAGGED_IMAGES.replace(':id', personId),
    { language, page }
  );
};

/**
 * Get a list of the translations that exist for a person.
 * @param {number} personId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-person-translations
 */
const translations$3 = async (personId, options = {}) => {
  const { language } = options;

  if (!personId && personId !== 0) {
    return Promise.reject('A personId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.PEOPLE_TRANSLATIONS.replace(':id', personId),
    {
      language,
    }
  );
};

/**
 * Get the TV show credits for a person.
 * You can query for some extra details about the credit with the credit.details method.
 * @param {number} personId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/people/get-person-tv-credits
 */
const tvCredits = async (personId, options = {}) => {
  const { language } = options;

  if (!personId && personId !== 0) {
    return Promise.reject('A personId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.PEOPLE_TV_CREDITS.replace(':id', personId),
    {
      language,
    }
  );
};

var people$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	changes: changes$3,
	combinedCredits: combinedCredits,
	details: details$6,
	externalIds: externalIds$3,
	images: images$3,
	latest: latest$1,
	movieCredits: movieCredits,
	popular: popular$1,
	taggedImages: taggedImages,
	translations: translations$3,
	tvCredits: tvCredits
});

/**
 * @module review
 */

/**
 * Get details of a review.
 * @param {string} reviewId
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/reviews/get-review-details
 */
const details$5 = async reviewId => {
  if (!reviewId) {
    return Promise.reject('A reviewId has to be provided');
  }

  return await makeHttpRequest(urls.v3.REVIEW_DETAILS.replace(':id', reviewId));
};

var review = /*#__PURE__*/Object.freeze({
	__proto__: null,
	details: details$5
});

/**
 * @module search
 */

/**
 * Search for collections.
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.query
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/search/search-collections
 */
const collections = async (options = {}) => {
  const { language, query, page } = options;

  if (!query) {
    return Promise.reject('A query has to be provided');
  }

  return await makeHttpRequest(urls.v3.SEARCH_COLLECTION, {
    language,
    query,
    page,
  });
};

/**
 * Search for companies.
 * @param {Object} options
 * @param {string} options.query
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/search/search-companies
 */
const companies = async (options = {}) => {
  const { query, page } = options;

  if (!query) {
    return Promise.reject('A query has to be provided');
  }

  return await makeHttpRequest(urls.v3.SEARCH_COMPANY, { query, page });
};

/**
 * Search for keywords.
 * @param {Object} options
 * @param {string} options.query
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/search/search-keywords
 */
const keywords$1 = async (options = {}) => {
  const { query, page } = options;

  if (!query) {
    return Promise.reject('A query has to be provided');
  }

  return await makeHttpRequest(urls.v3.SEARCH_KEYWORD, { query, page });
};

/**
 * Search for movies.
 * @param {Object}  options
 * @param {string}  options.language
 * @param {string}  options.query
 * @param {number}  options.page
 * @param {boolean} options.include_adult
 * @param {string}  options.region
 * @param {number}  option.year
 * @param {number}  option.primary_release_year
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/search/search-movies
 */
const movies = async (options = {}) => {
  const {
    language,
    query,
    page,
    include_adult,
    region,
    year,
    primary_release_year,
  } = options;

  if (!query) {
    return Promise.reject('A query has to be provided');
  }

  return await makeHttpRequest(urls.v3.SEARCH_MOVIE, {
    language,
    query,
    page,
    include_adult,
    region,
    year,
    primary_release_year,
  });
};

/**
 * Search multiple models in a single request. Multi search currently supports searching for movies, tv shows and people in a single request.
 * @param {Object}  options
 * @param {string}  options.language
 * @param {string}  options.query
 * @param {number}  options.page
 * @param {boolean} options.include_adult
 * @param {string}  options.region
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/search/multi-search
 */
const multi = async (options = {}) => {
  const { language, query, page, include_adult, region } = options;

  if (!query) {
    return Promise.reject('A query has to be provided');
  }

  return await makeHttpRequest(urls.v3.SEARCH_MULTI, {
    language,
    query,
    page,
    include_adult,
    region,
  });
};

/**
 * Search for people.
 * @param {Object}  options
 * @param {string}  options.language
 * @param {string}  options.query
 * @param {number}  options.page
 * @param {boolean} options.include_adult
 * @param {string}  options.region
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/search/search-people
 */
const people = async (options = {}) => {
  const { language, query, page, include_adult, region } = options;

  if (!query) {
    return Promise.reject('A query has to be provided');
  }

  return await makeHttpRequest(urls.v3.SEARCH_PEOPLE, {
    language,
    query,
    page,
    include_adult,
    region,
  });
};

/**
 * Search for a TV show.
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.query
 * @param {number} options.page
 * @param {number} options.first_air_date_year
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/search/search-tv-shows
 */
const tv$2 = async (options = {}) => {
  const { language, query, page, first_air_date_year } = options;

  if (!query) {
    return Promise.reject('A query has to be provided');
  }

  return await makeHttpRequest(urls.v3.SEARCH_TV, {
    language,
    query,
    page,
    first_air_date_year,
  });
};

var search = /*#__PURE__*/Object.freeze({
	__proto__: null,
	collections: collections,
	companies: companies,
	keywords: keywords$1,
	movies: movies,
	multi: multi,
	people: people,
	tv: tv$2
});

/**
 * @module trending
 */

/**
 * Get the daily or weekly trending items. The daily trending list tracks items over the period of a day while items have a 24 hour half life. The weekly list tracks items over a 7 day period, with a 7 day half life.
 * @param {Object} options
 * @param {('all'|'movie'|'tv'|'person')} options.media_type - Allowed values: all, movie, tv, person
 * @param {('day'|'week')} options.time_window - Allowed values: day, week
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/trending/get-trending
 */
const items = async (options = {}) => {
  const { media_type, time_window } = options;

  if (!media_type) {
    return Promise.reject('A media_type has to be provided');
  }

  if (!time_window) {
    return Promise.reject('A time_window has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TRENDING_ITEMS.replace(':mediaType', media_type).replace(
      ':timeWindow',
      time_window
    )
  );
};

var trending = /*#__PURE__*/Object.freeze({
	__proto__: null,
	items: items
});

/**
 * @module tv
 */

/**
 * Grab the following account states for a session:
 * TV show rating, If it belongs to your watchlist and If it belongs to your favourite list
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.session_id
 * @param {string} options.guest_session_id
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-account-states
 */
const accountStates$2 = async (tvId, options = {}) => {
  const { session_id, guest_session_id, language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (session_id || guest_session_id) {
    return await makeHttpRequest(
      urls.v3.TV_ACCOUNT_STATES.replace(':id', tvId),
      { session_id, guest_session_id, language }
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get the aggregate credits (cast and crew) that have been added to a TV show.
 * This call differs from the main credits call in that it does not return the newest season but rather,
 * is a view of all the entire cast & crew for all episodes belonging to a TV show.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-aggregate-credits
 */
const aggregateCredits$1 = async (tvId, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_AGGREGATE_CREDITS.replace(':id', tvId),
    {
      language,
    }
  );
};

/**
 * Get a list of TV shows that are airing today. This query is purely day based as we do not currently support airing times.
 * You can specify a timezone to offset the day calculation. Without a specified timezone, this query defaults to EST (Eastern Time UTC-05:00).
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-airing-today
 */
const airingToday = async (options = {}) => {
  const { language, page } = options;

  return await makeHttpRequest(urls.v3.TV_AIRING_TODAY, { language, page });
};

/**
 * Returns all of the alternative titles for a TV show.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-alternative-titles
 */
const alternativeTitles = async (tvId, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_ALTERNATIVE_TITLES.replace(':id', tvId),
    { language }
  );
};

/**
 * Get the changes for a TV show. By default only the last 24 hours are returned.
 * You can query up to 14 days in a single query by using the start_date and end_date options.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.start_date
 * @param {string} options.end_date
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-changes
 */
const changes$2 = async (tvId, options = {}) => {
  const { start_date, end_date, page } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_CHANGES.replace(':id', tvId), {
    start_date,
    end_date,
    page,
  });
};

/**
 * Get the list of content ratings (certifications) that have been added to a TV show.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-content-ratings
 */
const contentRatings = async (tvId, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_CONTENT_RATINGS.replace(':id', tvId),
    { language }
  );
};

/**
 * Get the credits (cast and crew) that have been added to a TV show.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-credits
 */
const credits$2 = async (tvId, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_CREDITS.replace(':id', tvId), {
    language,
  });
};

/**
 * Remove your rating for a TV show.
 * @param {number} tvId
 * @param {Object} options
 * @param {string} options.session_id
 * @param {string} options.guest_session_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/delete-tv-show-rating
 */
const deleteRating$1 = async (tvId, options = {}) => {
  const { session_id, guest_session_id } = options;
  if (!tvId) {
    return Promise.reject('A tvId has to be provided');
  }

  if (session_id || guest_session_id) {
    return await makeHttpRequest(
      urls.v3.TV_RATING.replace(':id', tvId),
      { session_id, guest_session_id },
      'delete'
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get the primary TV show details by id.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.append_to_response
 * @param {string} options.include_image_language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-details
 */
const details$4 = async (tvId, options = {}) => {
  const { language, append_to_response, include_image_language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_DETAILS.replace(':id', tvId), {
    language,
    append_to_response,
    include_image_language,
  });
};

/**
 * Get all of the episode groups that have been created for a TV show.
 * With a group ID you can call the tvEpisodeGroups.details method.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-credits
 */
const episodeGroups = async (tvId, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_EPISODE_GROUPS.replace(':id', tvId), {
    language,
  });
};

/**
 * Get the external ids for a TV show. We currently support the following external sources.
 * IMDB ID, TVDB ID, Freebase MID, Freebase ID, TVRage ID
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-external-ids
 */
const externalIds$2 = async (tvId, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_EXTERNAL_IDS.replace(':id', tvId), {
    language,
  });
};

/**
 * Get the images that belong to a TV show.
 * Querying images with a language parameter will filter the results.
 * If you want to include a fallback language (especially useful for backdrops)
 * you can use the include_image_language option.
 * This should be a comma separated value like so: include_image_language=en,null.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.include_image_language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-images
 */
const images$2 = async (tvId, options = {}) => {
  const { language, include_image_language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_IMAGES.replace(':id', tvId), {
    language,
    include_image_language,
  });
};

/**
 * Get the keywords that have been added to a TV show.
 * @param {number} tvId - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-keywords
 */
const keywords = async (tvId) => {
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_KEYWORDS.replace(':id', tvId));
};

/**
 * Get the most newly created TV show. This is a live response and will continuously change.
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-latest-tv
 */
const latest = async (options = {}) => {
  const { language } = options;

  return await makeHttpRequest(urls.v3.TV_LATEST, { language });
};

/**
 * Get a list of shows that are currently on the air.
 * This query looks for any TV show that has an episode with an air date in the next 7 days.
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-on-the-air
 */
const onTheAir = async (options = {}) => {
  const { language, page } = options;

  return await makeHttpRequest(urls.v3.TV_ON_THE_AIR, { language, page });
};

/**
 * Get a list of the current popular TV shows on TMDb.
 * This list updates daily.
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-popular-tv-shows
 */
const popular = async (options = {}) => {
  const { language, page } = options;

  return await makeHttpRequest(urls.v3.TV_POPULAR, {
    language,
    page,
  });
};

/**
 * Rate a TV episode.
 * @param {number} tvId - Required
 * @param {rating} rating - between 0.5 and 10.0
 * @param {Object} options
 * @param {string} options.session_id
 * @param {string} options.guest_session_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/rate-tv-show
 */
const rate$1 = async (tvId, rating, options = {}) => {
  const { session_id, guest_session_id } = options;
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!rating) {
    return Promise.reject('A rating has to be provided');
  }

  if (session_id || guest_session_id) {
    const queryParam = session_id
      ? `?session_id=${session_id}`
      : `?guest_session_id=${guest_session_id}`;
    return await makeHttpRequest(
      urls.v3.TV_RATING.replace(':id', tvId).concat(queryParam),
      { value: rating },
      'post'
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get the list of TV show recommendations for this item.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-recommendations
 */
const recommendations = async (tvId, options = {}) => {
  const { language, page } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_RECOMMENDATIONS.replace(':id', tvId),
    { language, page }
  );
};

/**
 * Get the reviews for a TV show.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-reviews
 */
const reviews = async (tvId, options = {}) => {
  const { language, page } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_REVIEWS.replace(':id', tvId), {
    language,
    page,
  });
};

/**
 * Get a list of seasons or episodes that have been screened in a film festival or theatre.
 * @param {number} tvId - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-screened-theatrically
 */
const screenedTheatrically = async (tvId) => {
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_SCREENED_THEATRICALLY.replace(':id', tvId)
  );
};

/**
 * Get a list of similar TV shows. These items are assembled by looking at keywords and genres.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-similar-tv-shows
 */
const similar = async (tvId, options = {}) => {
  const { language, page } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_SIMILAR.replace(':id', tvId), {
    language,
    page,
  });
};

/**
 * Get a list of the top rated TV shows on TMDb.
 * @param {Object} options
 * @param {string} options.language
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-top-rated-tv
 */
const topRated = async (options = {}) => {
  const { language, page } = options;

  return makeHttpRequest(urls.v3.TV_TOP_RATED, { language, page });
};

/**
 * Get a list of the translations that exist for a TV show.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-translations
 */
const translations$2 = async (tvId, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_TRANSLATIONS.replace(':id', tvId), {
    language,
  });
};

/**
 * Get the videos that have been added to a TV show.
 * @param {number} tvId - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv/get-tv-videos
 */
const videos$2 = async (tvId, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  return await makeHttpRequest(urls.v3.TV_VIDEOS.replace(':id', tvId), {
    language,
  });
};

/**
 * Powered by our partnership with JustWatch, you can query this method to get a list of the availabilities per country by provider.
 * This is not going to return full deep links, but rather, it's just enough information to display what's available where.
 * You can link to the provided TMDB URL to help support TMDB and provide the actual deep links to the content.
 * Please note: In order to use this data you must attribute the source of the data as JustWatch. If we find any usage not complying with these terms we will revoke access to the API.
 * @param {number} tvId
 * @return {Promise} Promise
 * @see https://developers.themoviedb.org/3/tv/get-tv-watch-providers
 */
const watchProviders = async (tvId) => {
  if (!tvId) {
    return Promise.reject('A tvId has to be provided');
  }

  return makeHttpRequest(urls.v3.TV_WATCH_PROVIDERS.replace(':id', tvId));
};

var tv$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	accountStates: accountStates$2,
	aggregateCredits: aggregateCredits$1,
	airingToday: airingToday,
	alternativeTitles: alternativeTitles,
	changes: changes$2,
	contentRatings: contentRatings,
	credits: credits$2,
	deleteRating: deleteRating$1,
	details: details$4,
	episodeGroups: episodeGroups,
	externalIds: externalIds$2,
	images: images$2,
	keywords: keywords,
	latest: latest,
	onTheAir: onTheAir,
	popular: popular,
	rate: rate$1,
	recommendations: recommendations,
	reviews: reviews,
	screenedTheatrically: screenedTheatrically,
	similar: similar,
	topRated: topRated,
	translations: translations$2,
	videos: videos$2,
	watchProviders: watchProviders
});

/**
 * @module tvEpisode
 */

/**
 * Get your rating for a episode.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {number} episodeNumber - Required
 * @param {Object} options
 * @param {string} options.session_id
 * @param {string} options.guest_session_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/get-tv-episode-account-states
 */
const accountStates$1 = async (
  tvId,
  seasonNumber,
  episodeNumber,
  options = {}
) => {
  const { session_id, guest_session_id } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (!episodeNumber && episodeNumber !== 0) {
    return Promise.reject('An episodeNumber has to be provided');
  }

  if (session_id || guest_session_id) {
    return await makeHttpRequest(
      urls.v3.TV_EPISODE_ACCOUNT_STATES.replace(':tvId', tvId)
        .replace(':seasonNumber', seasonNumber)
        .replace(':episodeNumber', episodeNumber),
      { session_id, guest_session_id }
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get the changes for a TV episode. By default only the last 24 hours are returned.
 * @param {number} episodeId - Required
 * @param {Object} options
 * @param {string} options.start_date
 * @param {string} options.end_date
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/get-tv-episode-changes
 */
const changes$1 = async (episodeId, options = {}) => {
  const { start_date, end_date, page } = options;

  if (!episodeId && episodeId !== 0) {
    return Promise.reject('An episodeId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_EPISODE_CHANGES.replace(':episodeId', episodeId),
    { start_date, end_date, page }
  );
};

/**
 * Get the credits (cast, crew and guest stars) for a TV episode.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {number} episodeNumber - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/get-tv-episode-credits
 */
const credits$1 = async (tvId, seasonNumber, episodeNumber) => {
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (!episodeNumber && episodeNumber !== 0) {
    return Promise.reject('An episodeNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_EPISODE_CREDITS.replace(':tvId', tvId)
      .replace(':seasonNumber', seasonNumber)
      .replace(':episodeNumber', episodeNumber)
  );
};

/**
 * Remove your rating for a TV episode.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {number} episodeNumber - Required
 * @param {Object} options
 * @param {string} options.session_id
 * @param {string} options.guest_session_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/delete-tv-episode-rating
 */
const deleteRating = async (
  tvId,
  seasonNumber,
  episodeNumber,
  options = {}
) => {
  const { session_id, guest_session_id } = options;
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (!episodeNumber && episodeNumber !== 0) {
    return Promise.reject('An episodeNumber has to be provided');
  }

  if (session_id || guest_session_id) {
    const queryParam = session_id
      ? `?session_id=${session_id}`
      : `?guest_session_id=${guest_session_id}`;
    return await makeHttpRequest(
      urls.v3.TV_EPISODE_RATING.replace(':tvId', tvId)
        .replace(':seasonNumber', seasonNumber)
        .replace(':episodeNumber', episodeNumber)
        .concat(queryParam),
      {},
      'delete'
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get the TV episode details by id.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {number} episodeNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.append_to_response
 * @param {string} options.include_image_language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/get-tv-episode-details
 */
const details$3 = async (
  tvId,
  seasonNumber,
  episodeNumber,
  options = {}
) => {
  const { language, append_to_response, include_image_language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (!episodeNumber && episodeNumber !== 0) {
    return Promise.reject('An episodeNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_EPISODE_DETAILS.replace(':tvId', tvId)
      .replace(':seasonNumber', seasonNumber)
      .replace(':episodeNumber', episodeNumber),
    { language, append_to_response, include_image_language }
  );
};

/**
 * Get the external ids for a TV episode. We currently support the following external sources:
 * IMDB ID, TVDB ID, Freebase MID, Freebase ID, TVRage ID
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {number} episodeNumber - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/get-tv-episode-external-ids
 */
const externalIds$1 = async (tvId, seasonNumber, episodeNumber) => {
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (!episodeNumber && episodeNumber !== 0) {
    return Promise.reject('An episodeNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_EPISODE_EXTERNAL_IDS.replace(':tvId', tvId)
      .replace(':seasonNumber', seasonNumber)
      .replace(':episodeNumber', episodeNumber)
  );
};

/**
 * Get the images that belong to a TV episode.
 * Querying images with a language parameter will filter the results.
 * If you want to include a fallback language (especially useful for backdrops)
 * you can use the include_image_language option.
 * This should be a comma separated value like so: include_image_language=en,null.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {number} episodeNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.include_image_language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/get-tv-episode-images
 */
const images$1 = async (
  tvId,
  seasonNumber,
  episodeNumber,
  options = {}
) => {
  const { language, include_image_language } = options;
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (!episodeNumber && episodeNumber !== 0) {
    return Promise.reject('An episodeNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_EPISODE_IMAGES.replace(':tvId', tvId)
      .replace(':seasonNumber', seasonNumber)
      .replace(':episodeNumber', episodeNumber),
    { language, include_image_language }
  );
};

/**
 * Rate a TV episode.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {number} episodeNumber - Required
 * @param {rating} rating - between 0.5 and 10.0
 * @param {Object} options
 * @param {string} options.session_id
 * @param {string} options.guest_session_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/rate-tv-episode
 */
const rate = async (
  tvId,
  seasonNumber,
  episodeNumber,
  rating,
  options = {}
) => {
  const { session_id, guest_session_id } = options;
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (!episodeNumber && episodeNumber !== 0) {
    return Promise.reject('An episodeNumber has to be provided');
  }

  if (!rating) {
    return Promise.reject('A rating has to be provided');
  }

  if (session_id || guest_session_id) {
    const queryParam = session_id
      ? `?session_id=${session_id}`
      : `?guest_session_id=${guest_session_id}`;
    return await makeHttpRequest(
      urls.v3.TV_EPISODE_RATING.replace(':tvId', tvId)
        .replace(':seasonNumber', seasonNumber)
        .replace(':episodeNumber', episodeNumber)
        .concat(queryParam),
      { value: rating },
      'post'
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get the translation data for an episode.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {number} episodeNumber - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/get-tv-episode-translations
 */
const translations$1 = async (tvId, seasonNumber, episodeNumber) => {
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (!episodeNumber && episodeNumber !== 0) {
    return Promise.reject('An episodeNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_EPISODE_TRANSLATIONS.replace(':tvId', tvId)
      .replace(':seasonNumber', seasonNumber)
      .replace(':episodeNumber', episodeNumber)
  );
};

/**
 * Get the videos that have been added to a TV episode.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {number} episodeNumber - Required
 * @param {Object} options
 * @param {string} language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episodes/get-tv-episode-videos
 */
const videos$1 = async (
  tvId,
  seasonNumber,
  episodeNumber,
  options = {}
) => {
  const { language } = options;
  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (!episodeNumber && episodeNumber !== 0) {
    return Promise.reject('An episodeNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_EPISODE_VIDEOS.replace(':tvId', tvId)
      .replace(':seasonNumber', seasonNumber)
      .replace(':episodeNumber', episodeNumber),
    { language }
  );
};

var tvEpisode = /*#__PURE__*/Object.freeze({
	__proto__: null,
	accountStates: accountStates$1,
	changes: changes$1,
	credits: credits$1,
	deleteRating: deleteRating,
	details: details$3,
	externalIds: externalIds$1,
	images: images$1,
	rate: rate,
	translations: translations$1,
	videos: videos$1
});

/**
 * @module tvEpisodeGroup
 */

/**
 * Get the details of a TV episode group.
 * Groups support 7 different types which are enumerated as the following:
 * 1 - Original air date, 2- Absolute, 3 - DVD, 4 - Digital, 5 - Story arc, 6 - Production, 7 - TV
 * @param {string} id
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-episode-groups/get-tv-episode-group-details
 */
const details$2 = async (id, options = {}) => {
  const { language } = options;

  if (!id) {
    return Promise.reject('An id has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_EPISODE_GROUP_DETAILS.replace(':id', id),
    { language }
  );
};

var tvEpisodeGroup = /*#__PURE__*/Object.freeze({
	__proto__: null,
	details: details$2
});

/**
 * @module tvSeason
 */

/**
 * Returns all of the user ratings for the season's episodes.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.session_id
 * @param {string} options.guest_session_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-seasons/get-tv-season-account-states
 */
const accountStates = async (tvId, seasonNumber, options = {}) => {
  const { language, session_id, guest_session_id } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  if (session_id || guest_session_id) {
    return await makeHttpRequest(
      urls.v3.TV_SEASON_ACCOUNT_STATES.replace(':tvId', tvId).replace(
        ':seasonNumber',
        seasonNumber
      ),
      { language, session_id, guest_session_id }
    );
  }

  return Promise.reject(
    'A session_id or a guest_session_id has to be provided'
  );
};

/**
 * Get the aggregate credits for TV season.
 * This call differs from the main credits call in
 * that it does not only return the season credits,
 * but rather is a view of all the cast & crew for all of the episodes belonging to a season.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-seasons/get-tv-season-aggregate-credits
 */
const aggregateCredits = async (tvId, seasonNumber, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_SEASON_AGGREGATE_CREDITS.replace(':id', tvId).replace(
      ':seasonNumber',
      seasonNumber
    ),
    {
      language,
    }
  );
};

/**
 * Get the changes for a TV season. By default only the last 24 hours are returned.
 * You can query up to 14 days in a single query by using the start_date and end_date query options.
 * @param {number} seasonId - Required
 * @param {Object} options
 * @param {string} options.start_date
 * @param {string} options.end_date
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-seasons/get-tv-season-changes
 */
const changes = async (seasonId, options = {}) => {
  const { start_date, end_date, page } = options;

  if (!seasonId && seasonId !== 0) {
    return Promise.reject('A seasonId has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_SEASON_CHANGES.replace(':seasonId', seasonId),
    { start_date, end_date, page }
  );
};

/**
 * Get the credits for TV season.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-seasons/get-tv-season-credits
 */
const credits = async (tvId, seasonNumber, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_SEASON_CREDITS.replace(':tvId', tvId).replace(
      ':seasonNumber',
      seasonNumber
    ),
    { language }
  );
};

/**
 * Get the TV season details by id.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.append_to_response
 * @param {string} options.include_image_language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-seasons/get-tv-season-details
 */
const details$1 = async (tvId, seasonNumber, options = {}) => {
  const { language, append_to_response, include_image_language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_SEASON_DETAILS.replace(':tvId', tvId).replace(
      ':seasonNumber',
      seasonNumber
    ),
    { language, append_to_response, include_image_language }
  );
};

/**
 * Get the external ids for a TV season. We currently support the following external sources.
 * TVDB ID, Freebase MID, Freebase ID, TVRage ID
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-seasons/get-tv-season-external-ids
 */
const externalIds = async (tvId, seasonNumber, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_SEASON_EXTERNAL_IDS.replace(':tvId', tvId).replace(
      ':seasonNumber',
      seasonNumber
    ),
    { language }
  );
};

/**
 * Get the images that belong to a TV season.
 * Querying images with a language parameter will filter the results.
 * If you want to include a fallback language (especially useful for backdrops)
 * you can use the include_image_language option.
 * This should be a: include_image_language comma separated value like so: include_image_language: "en,null".
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.include_image_language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-seasons/get-tv-season-images
 */
const images = async (tvId, seasonNumber, options = {}) => {
  const { language, include_image_language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_SEASON_IMAGES.replace(':tvId', tvId).replace(
      ':seasonNumber',
      seasonNumber
    ),
    { language, include_image_language }
  );
};

/**
 * Get the credits for TV season.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-seasons/get-tv-season-translations
 */
const translations = async (tvId, seasonNumber) => {
  if (!tvId) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  return makeHttpRequest(
    urls.v3.TV_SEASON_TRANSLATIONS.replace(':tvId', tvId).replace(
      ':seasonNumber',
      seasonNumber
    ),
    {
      language,
    }
  );
};

/**
 * Get the videos that have been added to a TV season.
 * @param {number} tvId - Required
 * @param {number} seasonNumber - Required
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/tv-seasons/get-tv-season-videos
 */
const videos = async (tvId, seasonNumber, options = {}) => {
  const { language } = options;

  if (!tvId && tvId !== 0) {
    return Promise.reject('A tvId has to be provided');
  }

  if (!seasonNumber && seasonNumber !== 0) {
    return Promise.reject('A seasonNumber has to be provided');
  }

  return await makeHttpRequest(
    urls.v3.TV_SEASON_VIDEOS.replace(':tvId', tvId).replace(
      ':seasonNumber',
      seasonNumber
    ),
    { language }
  );
};

var tvSeason = /*#__PURE__*/Object.freeze({
	__proto__: null,
	accountStates: accountStates,
	aggregateCredits: aggregateCredits,
	changes: changes,
	credits: credits,
	details: details$1,
	externalIds: externalIds,
	images: images,
	translations: translations,
	videos: videos
});

/**
 * @module watchProvider
 */

/**
 * Returns a list of all of the countries we have watch provider (OTT/streaming) data for.
 * @param {Object} options
 * @param {string} options.language
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/watch-providers/get-available-regions
 */
const availableRegions = async (options = {}) => {
  const { language } = options;

  return await makeHttpRequest(urls.v3.WATCH_PROVIDERS_AVAILABLE_REGIONS, {
    language,
  });
};

/**
 * Returns a list of the watch provider (OTT/streaming) data we have available for movies.
 * You can specify a watch_region param if you want to further filter the list by country.
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.watch_region
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/watch-providers/get-movie-providers
 */
const movie = async (options = {}) => {
  const { language, watch_region } = options;

  return await makeHttpRequest(urls.v3.WATCH_PROVIDERS_MOVIE, {
    language,
    watch_region,
  });
};

/**
 * Returns a list of the watch provider (OTT/streaming) data we have available for TV series.
 * You can specify a watch_region param if you want to further filter the list by country.
 * @param {Object} options
 * @param {string} options.language
 * @param {string} options.watch_region
 * @returns {Promise}
 * @see https://developers.themoviedb.org/3/watch-providers/get-tv-providers
 */
const tv = async (options = {}) => {
  const { language, watch_region } = options;

  return await makeHttpRequest(urls.v3.WATCH_PROVIDERS_TV, {
    language,
    watch_region,
  });
};

var watchProvider = /*#__PURE__*/Object.freeze({
	__proto__: null,
	availableRegions: availableRegions,
	movie: movie,
	tv: tv
});

var v3Import = {
  account: account$1,
  authentication: authentication$1,
  certification,
  change,
  collection,
  company,
  configuration,
  credit,
  discover,
  find,
  genre,
  guestSession,
  keyword,
  list: list$1,
  movie: movie$1,
  network,
  people: people$1,
  review,
  search,
  trending,
  tv: tv$1,
  tvEpisode,
  tvEpisodeGroup,
  tvSeason,
  watchProvider,
};

/**
 * @module account
 */

/**
 * Get the list of movies you have marked as a favorite.
 * @param {string} accessToken - Required
 * @param {string} accountId - Required
 * @param {Object} options
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc'|'release_date.asc'|'release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc, release_date.asc,
 * release_date.desc, title.asc, title.desc, vote_average.asc, vote_average.desc,
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/account/get-account-favorite-movies
 */
const favoriteMovies = async (accessToken, accountId, options = {}) => {
  const { page, sort_by } = options;

  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!accountId) {
    return Promise.reject('An accountId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_FAVORITE_MOVIES.replace(':id', accountId),
    { page, sort_by },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * Get the list of TV shows you have marked as a favorite.
 * @param {string} accessToken - Required
 * @param {string} accountId - Required
 * @param {Object} options
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc'|'release_date.asc'|'release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc, release_date.asc,
 * release_date.desc, title.asc, title.desc, vote_average.asc, vote_average.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/account/get-account-favorite-tv-shows
 */
const favoriteTvShows = async (accessToken, accountId, options = {}) => {
  const { page, sort_by } = options;

  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!accountId) {
    return Promise.reject('An accountId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_FAVORITE_TV_SHOWS.replace(':id', accountId),
    { page, sort_by },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * Get all of the lists you have created.
 * @param {string} accessToken - Required
 * @param {string} accountId - Required
 * @param {Object} options
 * @param {number} options.page
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/account/get-account-lists
 */
const lists = async (accessToken, accountId, options = {}) => {
  const { page } = options;

  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!accountId) {
    return Promise.reject('An accountId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_LISTS.replace(':id', accountId),
    { page },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * Get a list of your personal movie recommendations.
 * @param {string} accessToken - Required
 * @param {string} accountId - Required
 * @param {Object} options
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc'|'release_date.asc'|'release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc, release_date.asc,
 * release_date.desc, title.asc, title.desc, vote_average.asc, vote_average.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/account/get-account-movie-recommendations
 */
const movieRecommendations = async (
  accessToken,
  accountId,
  options = {}
) => {
  const { page, sort_by } = options;

  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!accountId) {
    return Promise.reject('An accountId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_MOVIE_RECOMMENDATIONS.replace(':id', accountId),
    { page, sort_by },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * Get the list of movies you have added to your watchlist.
 * @param {string} accessToken - Required
 * @param {string} accountId - Required
 * @param {Object} options
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc'|'release_date.asc'|'release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc, release_date.asc,
 * release_date.desc, title.asc, title.desc, vote_average.asc, vote_average.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/account/get-account-movie-watchlist
 */
const movieWatchlist = async (accessToken, accountId, options = {}) => {
  const { page, sort_by } = options;

  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!accountId) {
    return Promise.reject('An accountId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_MOVIE_WATCHLIST.replace(':id', accountId),
    { page, sort_by },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * Get the list of movies you have rated.
 * @param {string} accessToken - Required
 * @param {string} accountId - Required
 * @param {Object} options
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc'|'release_date.asc'|'release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc, release_date.asc,
 * release_date.desc, title.asc, title.desc, vote_average.asc, vote_average.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/account/get-account-rated-movies
 */
const ratedMovies = async (accessToken, accountId, options = {}) => {
  const { page, sort_by } = options;

  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!accountId) {
    return Promise.reject('An accountId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_RATED_MOVIES.replace(':id', accountId),
    { page, sort_by },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * Get the list of TV shows you have rated.
 * @param {string} accessToken - Required
 * @param {string} accountId - Required
 * @param {Object} options
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc'|'release_date.asc'|'release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc, release_date.asc,
 * release_date.desc, title.asc, title.desc, vote_average.asc, vote_average.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/account/get-account-rated-tv-shows
 */
const ratedTvShows = async (accessToken, accountId, options = {}) => {
  const { page, sort_by } = options;

  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!accountId) {
    return Promise.reject('An accountId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_RATED_TV_SHOWS.replace(':id', accountId),
    { page, sort_by },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * Get a list of your personal TV show recommendations.
 * @param {string} accessToken - Required
 * @param {string} accountId - Required
 * @param {Object} options
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc'|'release_date.asc'|'release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc, release_date.asc,
 * release_date.desc, title.asc, title.desc, vote_average.asc, vote_average.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/account/get-account-tv-show-recommendations
 */
const tvShowRecommendations = async (
  accessToken,
  accountId,
  options = {}
) => {
  const { page, sort_by } = options;

  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!accountId) {
    return Promise.reject('An accountId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_TV_SHOW_RECOMMENDATIONS.replace(':id', accountId),
    { page, sort_by },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * Get the list of TV shows you have added to your watchlist.
 * @param {string} accessToken - Required
 * @param {string} accountId - Required
 * @param {Object} options
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc'|'release_date.asc'|'release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc, release_date.asc,
 * release_date.desc, title.asc, title.desc, vote_average.asc, vote_average.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/account/get-account-tv-show-watchlist
 */
const tvShowWatchlist = async (accessToken, accountId, options = {}) => {
  const { page, sort_by } = options;

  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!accountId) {
    return Promise.reject('An accountId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_TV_SHOW_WATCHLIST.replace(':id', accountId),
    { page, sort_by },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

var account = /*#__PURE__*/Object.freeze({
	__proto__: null,
	favoriteMovies: favoriteMovies,
	favoriteTvShows: favoriteTvShows,
	lists: lists,
	movieRecommendations: movieRecommendations,
	movieWatchlist: movieWatchlist,
	ratedMovies: ratedMovies,
	ratedTvShows: ratedTvShows,
	tvShowRecommendations: tvShowRecommendations,
	tvShowWatchlist: tvShowWatchlist
});

/**
 * @module authentication
 */

/**
 * This method will finish the user authentication flow and issue an official user access token.
 * The requesToken in this request is sent along as part of the POST body.
 * @param {string} requestToken
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/auth/create-access-token
 */
const createAccessToken = async requestToken => {
  if (!requestToken) {
    return Promise.reject('A requestToken has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.AUTH_ACCESS_TOKEN,
    { request_token: requestToken },
    'post',
    { usev4: true }
  );
};

/**
 * This method generates a new request token that you can ask a user to approve.
 * This is the first step in getting permission from a user to read and write data on their behalf.
 * Note that there is an optional body you can post alongside this request to set a redirect URL
 * or callback that will be executed once a request token has been approved on TMDb.

 * @param {string} redirectTo
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/auth/create-request-token
 */
const createRequestToken = async redirectTo => {
  return await makeHttpRequest(
    urls.v4.AUTH_REQUEST_TOKEN,
    { redirect_to: redirectTo },
    'post',
    { usev4: true }
  );
};

/**
 * This method gives your users the ability to log out of a session.
 * @param {string} accessToken
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/auth/delete-access-token
 */
const deleteAccessToken = async accessToken => {
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.AUTH_ACCESS_TOKEN,
    { access_token: accessToken },
    'delete',
    { usev4: true }
  );
};

var authentication = /*#__PURE__*/Object.freeze({
	__proto__: null,
	createAccessToken: createAccessToken,
	createRequestToken: createRequestToken,
	deleteAccessToken: deleteAccessToken
});

/**
 * @module list
 */

/**
 * This method will let you add items to a list.
 * We support essentially an unlimited number of items to be posted at a time.
 * Both movie and TV series are supported.
 * The results of this query will return a results array.
 * Each result includes a success field. If a result is false this will usually indicate
 * that the item already exists on the list. It may also indicate that the item could not be found.
 * You must be the owner of the list and therefore have a valid user access token in order to add items to a list.
 * @param {string}   accessToken - Required
 * @param {number}   listId - Required
 * @param {Object[]} items - Required
 * @param {('movie'|'tv')} items[].media_type - Allowed values: movie, tv
 * @param {number}   items[].media_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/list/add-items
 */
const addItems = async (accessToken, listId, items = []) => {
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!listId && listId !== 0) {
    return Promise.reject('A listId has to be provided');
  }

  if (items.length) {
    return await makeHttpRequest(
      urls.v4.ACCOUNT_LIST_ITEMS.replace(':id', listId),
      { items },
      'post',
      { usev4: true, userAccessToken: accessToken }
    );
  }

  return Promise.reject('At least an item has to be provided');
};

/**
 * This method lets you clear all of the items from a list in a single request. This action cannot be reversed so use it with caution.
 * You must be the owner of the list and therefore have a valid user access token in order to clear a list.
 * @param {string} accessToken - Required
 * @param {number} listId - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/list/clear-list
 */
const clearItems = async (accessToken, listId) => {
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!listId && listId !== 0) {
    return Promise.reject('A listId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_LIST_CLEAR_ITEMS.replace(':id', listId),
    {},
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * This method will create a new list.
 * You will need to have valid user access token in order to create a new list.
 * @param {string}  accessToken - Required
 * @param {object}  options - Required
 * @param {string}  options.name - Required
 * @param {string}  options.iso_639_1 - Required
 * @param {string}  options.description
 * @param {boolean} options.public
 * @param {string}  options.iso_3166_1
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/list/create-list
 */
const create = async (accessToken, options = {}) => {
  const { name, iso_639_1, ...rest } = options;
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (name && iso_639_1) {
    return await makeHttpRequest(
      urls.v4.ACCOUNT_LIST_CREATE,
      { name, iso_639_1, ...rest },
      'post',
      { usev4: true, userAccessToken: accessToken }
    );
  }

  return Promise.reject('A name and a iso_639_1 option has to be provided');
};

/**
 * This method will retrieve a list by id.
 * Private lists can only be accessed by their owners and therefore require a valid user access token.
 * @param {string} accessToken - Required
 * @param {number} listId - Required
 * @param {object} options
 * @param {string} options.language
 * @param {number} options.page
 * @param {('created_at.asc'|'created_at.desc'|'release_date.asc'|'release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')} options.sort_by - Allowed values: created_at.asc, created_at.desc, release_date.asc,
 * release_date.desc, title.asc, title.desc, vote_average.asc, vote_average.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/list/get-list
 */
const details = async (accessToken, listId, options = {}) => {
  const { language, page, sort_by } = options;
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!listId && listId !== 0) {
    return Promise.reject('A listId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_LIST_DETAILS.replace(':id', listId),
    { language, page, sort_by },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * This method will let you remove items from a list. You can remove multiple items at a time.
 * You must be the owner of the list and therefore have a valid user access token in order to delete items from it.
 * @param {string}   accessToken - Required
 * @param {number}   listId - Required
 * @param {Object[]} items - Required
 * @param {('movie'|'tv')}   items[].media_type - Allowed values: movie, tv
 * @param {number}   items[].media_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/list/remove-items
 */
const deleteItems = async (accessToken, listId, items = []) => {
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!listId && listId !== 0) {
    return Promise.reject('A listId has to be provided');
  }

  if (items.length) {
    return await makeHttpRequest(
      urls.v4.ACCOUNT_LIST_ITEMS.replace(':id', listId),
      { items },
      'delete',
      { usev4: true, userAccessToken: accessToken }
    );
  }

  return Promise.reject('At least an item has to be provided');
};

/**
 * This method lets you quickly check if the item is already added to the list.
 * You must be the owner of the list and therefore have a valid user access token in order to check an item status.
 * @param {string} accessToken - Required
 * @param {number} listId - Required
 * @param {object} item
 * @param {('movie'|'tv')} item.media_type - Allowed values: movie, tv
 * @param {number} item.media_id
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/list/check-item-status
 */
const itemStatus = async (accessToken, listId, item = {}) => {
  const { media_id, media_type } = item;
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!listId && listId !== 0) {
    return Promise.reject('A listId has to be provided');
  }

  if (!item || !Object.keys(item).length) {
    return Promise.reject('At least an item has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_LIST_ITEMS.replace(':id', listId),
    { media_id, media_type },
    'get',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * This method will delete a list by id. This action is not reversible so take care when issuing it.
 * You must be the owner of the list and therefore have a valid user access token in order to delete it.
 * @param {string}   accessToken - Required
 * @param {number}   listId - Required
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/list/delete-list
 */
const remove = async (accessToken, listId) => {
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!listId && listId !== 0) {
    return Promise.reject('A listId has to be provided');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_LIST_DETAILS.replace(':id', listId),
    {},
    'delete',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * This method will let you update the details of a list.
 * You must be the owner of the list and therefore have a valid user access token in order to edit it.
 * @param {string}  accessToken - Required
 * @param {number}  listId - Required
 * @param {object}  options - Required
 * @param {string}  options.name - Required
 * @param {string}  options.description
 * @param {boolean} options.public
 * @param {('original_order.asc'|'original_order.desc'|'primary_release_date.asc'|'primary_release_date.desc'|'title.asc'|'title.desc'|'vote_average.asc'|'vote_average.desc')}  options.sort_by - Allowed values: original_order.asc, original_order.desc, vote_average.asc, vote_average.desc, primary_release_date.asc, primary_release_date.desc, title.asc, title.desc
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/list/update-list
 */
const update = async (accessToken, listId, body = {}) => {
  const { sort_by, ...rest } = body;
  const toUpdate = { ...rest };
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!listId && listId !== 0) {
    return Promise.reject('A listId has to be provided');
  }

  if (!toUpdate || !Object.keys(toUpdate).length) {
    return Promise.reject('Nothing to update');
  }

  return await makeHttpRequest(
    urls.v4.ACCOUNT_LIST_DETAILS.replace(':id', listId),
    toUpdate,
    'put',
    { usev4: true, userAccessToken: accessToken }
  );
};

/**
 * This method will let you update an individual item on a list. Currently, only adding a comment is suported.
 * You must be the owner of the list and therefore have a valid user access token in order to edit items.
 * @param {string}   accessToken - Required
 * @param {number}   listId - Required
 * @param {Object[]} items - Required
 * @param {('movie'|'tv')}   items[].media_type - Allowed values: movie, tv
 * @param {number}   items[].media_id
 * @param {string}   items[].comment
 * @returns {Promise}
 * @see https://developers.themoviedb.org/4/list/update-items
 */
const updateItems = async (accessToken, listId, items = []) => {
  if (!accessToken) {
    return Promise.reject('An accessToken has to be provided');
  }

  if (!listId && listId !== 0) {
    return Promise.reject('A listId has to be provided');
  }

  if (items.length) {
    return await makeHttpRequest(
      urls.v4.ACCOUNT_LIST_ITEMS.replace(':id', listId),
      { items },
      'put',
      { usev4: true, userAccessToken: accessToken }
    );
  }

  return Promise.reject('At least an item has to be provided');
};

var list = /*#__PURE__*/Object.freeze({
	__proto__: null,
	addItems: addItems,
	clearItems: clearItems,
	create: create,
	details: details,
	deleteItems: deleteItems,
	itemStatus: itemStatus,
	remove: remove,
	update: update,
	updateItems: updateItems
});

var v4Import = {
  account,
  authentication,
  list,
};

/**
 * Get all of v3 methods available
 * @param {string} v3apiKey - Required
 * @returns All of v3 methods available
 * @see https://developers.themoviedb.org/3/getting-started/introduction
 */
const v3 = (apiKey) => {
  setV3Key(apiKey);

  return v3Import;
};

/**
 * Get all of v4 methods available
 * @param {string} v4apiKey - Required
 * @returns All of v4 methods available
 * @see https://developers.themoviedb.org/4/getting-started
 */
const v4 = (apiKey) => {
  setV4Key(apiKey);

  return v4Import;
};

exports.v3 = v3;
exports.v4 = v4;
